extern "C" %{
#include "tree_dist.h"
#include "dague/sys/atomic.h"

struct __dague_walk_internal_handle;
struct __dague_walk_UP_assignment_s;
struct __dague_walk_DOWN_assignment_s;
struct __dague_walk_DO_DOWN_assignment_s;
struct __dague_walk_DOWN_task_s;

static uint64_t up_hash(const struct __dague_walk_internal_handle * __dague_handle,
                        struct __dague_walk_UP_assignment_s * assignments);
static uint64_t down_hash(const struct __dague_walk_internal_handle * __dague_handle,
                          struct __dague_walk_DOWN_assignment_s * assignments);
static uint64_t do_down_hash(const struct __dague_walk_internal_handle * __dague_handle,
                             struct __dague_walk_DO_DOWN_assignment_s * assignments);
static uint32_t undetermined_nb_tasks(struct __dague_walk_internal_handle *__dague_handle);

static void               *my_alloc_deps(struct __dague_walk_internal_handle *__dague_handle);
static void                my_free_deps(struct __dague_walk_internal_handle *__dague_handle, void *deps);
static dague_dependency_t *my_find_deps(const dague_handle_t *dague_handle,
                                        const dague_execution_context_t* restrict exec_context);

static int my_walk_startup(dague_execution_unit_t * eu,
                           struct __dague_walk_DOWN_task_s * this_task);
#include "walk_utils.h"
%}

// These are global variables that are instanciated in the main.c
tree               [type = "tree_dist_t *"]
// The only type known to parsec is dague_ddesc_t
treeDesc           [type = "dague_ddesc_t *" default = "(dague_ddesc_t*)tree"]
NP                 [type = "int"]
fakeDesc           [type = "dague_ddesc_t *"]
on_fct_param       [type = "void*"]
on_node_down       [type = "walk_fn_t"]
on_node_up         [type = "walk_fn_t"] 
tasks_done_locally [type = "uint32_t"]
verbose            [type = "int"]

BCAST_UP(rank)
  rank = 0 .. (NP-1)

:fakeDesc(rank, rank)

CTL RL <- RL UP(0, 0)

BODY
{
    dague_handle_set_nbtask(&__dague_handle->super.super, 1);
    if( verbose ) {
        fprintf(stderr, "Rank %d in BCAST_UP, counted %d tasks executed; nb_tasks = %d\n", rank,
                tasks_done_locally, __dague_handle->super.super.nb_tasks);
    }
}
END

// UP is used to go back up in thre tree.
// The algorithm is the following :
// 1- The parent of leaf nodes is expecting control messages from the task DOWN
// 2- Once it receives these messages, it sends a control message to its parent task
// 3- The parent of parent node receives the controls from UP
// 4- Once the root node receives both its children controls, the tree
//    is built and all the remaining tasks are killed

UP (n, l) [hash_fn = up_hash
           nb_local_tasks_fn = undetermined_nb_tasks
           find_deps_fn  = my_find_deps
           alloc_deps_fn = my_alloc_deps
           free_deps_fn  = my_free_deps ]
n = 0 .. 31
l = 0 .. 1<<n

:treeDesc(n, l)

 // The controls (CTL) are used as counters. Each UP task
 // has to receive exactly two controls. But, the parent of leaf nodes
 // should receive the CTL from the DOWN tasks and all the other
 // parent nodes receive them from UP. Thus, it is not
 // possible to write a condition which explicitely says from which
 // task the control was received (in other words, we cannot know if
 // the child nodes are leaves or node without more information).
 // Fortunately, we know exactly how many controls a task is waiting (2)
 // and the runtime does not check the id of the task sending the controls,
 // instead, it just counts the number of controls.

CTL LEFT  <- 1 ? RL UP(n+1, 2*l) : RL DOWN(n+1, 2*l)
 // The line above says that the left control is received from
 // the left control of the task up(lid) if true.
 // For the runtime, this just means that a control has to be received

CTL RIGHT <- 1 ? RL UP(n+1, 2*l+1) : RL DOWN(n+1, 2*l+1)

//Once both controls are received, this task sends the control
// to its parent on the right or on the left control of its parent
// depending on its n and its l
CTL RL    -> (((l%2) == 0) & (n>0)) ? LEFT UP(n-1, l/2)
          -> (((l%2) == 1) & (n>0)) ? RIGHT UP(n-1, l/2)
          -> (n==0) ? RL BCAST_UP(0 .. (NP-1))

READ NODE <- NODE DO_DOWN(n, l)
     
BODY
{
    /* The root node has to delete all remaining tasks*/
    node_t *node = (node_t*)NODE;
    if( verbose ) {
        int rank;
        MPI_Comm_rank(MPI_COMM_WORLD, &rank);
        fprintf(stderr, "CALLING UP(%d, %d) on rank %d\n", n, l, rank);
    }
    dague_atomic_inc_32b(&tasks_done_locally);
    if( NULL != on_node_up ) {
        on_node_up(tree, node, n, l, on_fct_param);
    }
}
END

// The algorithms of the project task is the following :
// 1- The root task :
//    a- It is automatically inserted in the tree
//    b- It creates it's children node
//    c- It sends the pointer of the created left node (NODEL) and right
//    node (NODER) to it's children
// 2- The children node :
//    a- A child node receives the pointer to its node from its father
//    (received in NODEB)
//    b- If it's error is less than the threshold, it update's its s
//       value (nodeb -> s) and sends the info to its father with the task
//       UP
//    c- Otherwise, it creates its children and send the node pointer
//       (just like the root)

DOWN (n, l) [hash_fn = down_hash
             nb_local_tasks_fn = undetermined_nb_tasks
             find_deps_fn  = my_find_deps
             alloc_deps_fn = my_alloc_deps
             free_deps_fn  = my_free_deps
             startup_fn = my_walk_startup ]
  n = 0 .. 31
  l = 0 .. (1<<n)
  node_exists = 1

:treeDesc(n, l)

// If the err <= thresh, then the control is send to the parent
// node either on its left or its right to stop the node creation
CTL RL      <- (n > 0) ? RL DOWN(n-1, l/2)
            -> node_exists ? RL DOWN(n+1, 2*l)
            -> node_exists ? RL DOWN(n+1, 2*l+1)
            -> node_exists ? RL DO_DOWN(n, l)
    -> ((!node_exists) & ( (l%2) == 0 )) ? LEFT UP(n-1, l/2)
    -> ((!node_exists) & ( (l%2) == 1 )) ? RIGHT UP(n-1, l/2)

BODY
{
    if( verbose ) {
        int rank;
        MPI_Comm_rank(MPI_COMM_WORLD, &rank);
        fprintf(stderr, "CALLING DOWN(%d, %d) on rank %d\n", n, l, rank);
    }

    if( tree_dist_lookup_node(tree, n, l) == -1 ) {
        if( verbose ) {
            int rank;
            MPI_Comm_rank(MPI_COMM_WORLD, &rank);
            fprintf(stderr, "Node (%d, %d) does not exist on rank %d\n", n, l, rank);
        }
        this_task->locals.node_exists.value = 0;
    }
    
    dague_atomic_inc_32b(&tasks_done_locally);
}
END

DO_DOWN (n, l) [hash_fn = do_down_hash
                nb_local_tasks_fn = undetermined_nb_tasks
                find_deps_fn = my_find_deps
                alloc_deps_fn = my_alloc_deps
                free_deps_fn = my_free_deps]
  n = 0 .. 31
  l = 0 .. (1<<n)

:treeDesc(n, l)

CTL RL    <- RL DOWN(n, l)
READ NODE <- treeDesc(n, l)
          -> NODE UP(n, l)

BODY
{
    node_t *node = (node_t*)NODE;
    if( verbose ) {
        int rank;
        MPI_Comm_rank(MPI_COMM_WORLD, &rank);
        fprintf(stderr, "CALLING DO_DOWN(%d, %d) on rank %d\n", n, l, rank);
    }

    dague_atomic_inc_32b(&tasks_done_locally);
    if( NULL != on_node_down ) {
        on_node_down(tree, node, n, l, on_fct_param);
    }
}
END

extern "C" %{
static uint64_t my_simple_tree_hash(int n, int l)
{
    return (((uint64_t)n) << 32) | ((uint64_t)l);
}

static uint64_t up_hash(const struct __dague_walk_internal_handle * __dague_handle,
                        struct __dague_walk_UP_assignment_s * assignments)
{
    (void)__dague_handle;
    return my_simple_tree_hash(assignments->n.value, assignments->l.value);
}

static uint64_t down_hash(const struct __dague_walk_internal_handle * __dague_handle,
                          struct __dague_walk_DOWN_assignment_s * assignments)
{
    (void)__dague_handle;
    return my_simple_tree_hash(assignments->n.value, assignments->l.value);
}

static uint64_t do_down_hash(const struct __dague_walk_internal_handle * __dague_handle,
                             struct __dague_walk_DO_DOWN_assignment_s * assignments)
{
    (void)__dague_handle;
    return my_simple_tree_hash(assignments->n.value, assignments->l.value);
}

 
static uint32_t undetermined_nb_tasks(struct __dague_walk_internal_handle *__dague_handle)
{
    (void)__dague_handle;
    return DAGUE_UNDETERMINED_NB_TASKS;
}

typedef struct {
    int n;
    int l;
    dague_dependency_t dep;
} simple_hash_entry_t;

typedef struct {
    int size;
    int used;
    simple_hash_entry_t **buckets;
} simple_hash_t;

static void               *my_alloc_deps(struct __dague_walk_internal_handle *__dague_handle)
{
    simple_hash_t *sh;
    (void)__dague_handle;
    sh = (simple_hash_t*)malloc(sizeof(simple_hash_t));
    sh->size = 6000;
    sh->used = 0;
    sh->buckets = (simple_hash_entry_t**)calloc(sh->size, sizeof(simple_hash_entry_t *));
    return (void*)sh;
}

static void                my_free_deps(struct __dague_walk_internal_handle *__dague_handle, void *deps)
{
    simple_hash_t *sh;
    int i;
    (void)__dague_handle;
    sh = (simple_hash_t*)deps;
    for(i = 0; i < sh->size; i++)
        if( sh->buckets[i] !=  NULL )
            free(sh->buckets[i]);
    free(sh->buckets);
    free(sh);
}

static dague_dependency_t *my_find_deps(const dague_handle_t *dague_handle,
                                        const dague_execution_context_t* restrict exec_context)
{
    simple_hash_t *sh;
    simple_hash_entry_t *ne = NULL;
    int p, i;
    int n, l;
    
    n = exec_context->locals[0].value;
    l = exec_context->locals[1].value;
    
    sh = (simple_hash_t*)dague_handle->dependencies_array[ exec_context->function->function_id ];
    p = my_simple_tree_hash(n, l) % sh->size;
    for(i = p; i != p-1; i = ((i+1) % sh->size)) {
        if( NULL == sh->buckets[i] ) {
            /** Empty spot: I'm not in the hash, I try to take it */
            if( NULL == ne ) {
                ne = (simple_hash_entry_t*)malloc(sizeof(simple_hash_entry_t));
                ne->n = n;
                ne->l = l;
                ne->dep = (dague_dependency_t)0;
            }
            if( dague_atomic_cas(&sh->buckets[i], NULL, ne) )
                return &ne->dep;
        }
        if( (sh->buckets[i]->n == n) && (sh->buckets[i]->l == l) ) {
            if(ne) free(ne);
            return &sh->buckets[i]->dep;
        }
    }
    fprintf(stderr, "Simple hash overflow: %d elements already inserted in the hash table\n", sh->size);
    exit(1); /** Catastrophic failure */
}

static int my_walk_startup(dague_execution_unit_t * eu, __dague_walk_DOWN_task_t * this_task)
{
  __dague_walk_DOWN_task_t *new_task;
  __dague_walk_internal_handle_t *__dague_handle = (__dague_walk_internal_handle_t *) this_task->dague_handle;
  int vpid = 0;
  dague_context_t *context = __dague_handle->super.super.context;

  if (__dague_handle->super.treeDesc->myrank != 0)
      return DAGUE_HOOK_RETURN_DONE;
  if (NULL != ((dague_ddesc_t *) __dague_handle->super.tree)->vpid_of) {
      vpid = ((dague_ddesc_t *) __dague_handle->super.tree)->vpid_of((dague_ddesc_t *) __dague_handle->super.tree, 0, 0);
      assert(context->nb_vp >= vpid);
  }
  new_task = (__dague_walk_DOWN_task_t *) dague_thread_mempool_allocate(context->virtual_processes[0]->execution_units[0]->context_mempool);
  new_task->status = DAGUE_TASK_STATUS_NONE;
  new_task->dague_handle = this_task->dague_handle;
  new_task->function = __dague_handle->super.super.functions_array[walk_DOWN.function_id];
  new_task->chore_id = 0;

  new_task->locals.n.value = 0;
  new_task->locals.l.value = 0;
  new_task->locals.node_exists.value = 1;

  new_task->data.RL.data_repo = NULL;
  new_task->data.RL.data_in = NULL;
  new_task->data.RL.data_out = NULL;

  new_task->priority = 1;

  DAGUE_LIST_ITEM_SINGLETON(new_task);
  __dague_schedule(eu, (dague_execution_context_t *)new_task);
  return DAGUE_HOOK_RETURN_DONE;
}

%}
