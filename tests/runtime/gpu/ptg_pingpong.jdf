extern "C" %{
/*
 * Copyright (c) 2023     The University of Tennessee and The University
 *                         of Tennessee Research Foundation.  All rights
 *                         reserved.
 */

#include "parsec/parsec_config.h"
#include "parsec/utils/mca_param.h"
#include "parsec/data_dist/matrix/two_dim_rectangle_cyclic.h"

#include <assert.h>
#include <stdarg.h>
#include <sys/time.h>
#include <mpi.h>

#include "ptg_pingpong.h"

#if defined(PARSEC_HAVE_DEV_CUDA_SUPPORT)
extern void cuda_pong_kernel(int *dev_data, int idx);
#endif
#if defined(PARSEC_HAVE_DEV_HIP_SUPPORT)
extern void hip_pong_kernel(int *dev_data, int idx);
#endif

int rank_of_token(int k);
int device_of_token(int k);

%}

/*
 * Globals
 */


dist     [type = "parsec_tiled_matrix_t*"]
NB_TOKEN [type = "int"]
NB_ERR   [type = "int*"]

INIT(k)
  k = 0 .. 0

: dist(0, 0)

WRITE T <- NEW
        -> T TOKEN_CPU(0)

BODY 
{
    int *tile = (int*)T;
    for(int i = 0; i < 2*NB_TOKEN; i++) tile[i] = i;
}
END

TOKEN_CPU(k)
 k = 0 .. NB_TOKEN-1
 r = %{ return rank_of_token(k); %}

: dist(r, 0)

RW T <- k == 0 ? T INIT(0) : T TOKEN_GPU(k-1, 1)
     -> T TOKEN_GPU(k, 0)

BODY
{
    int *tile = (int*)T;
    tile[2*k] += 2*k;
    tile[2*k+1] += 2*k+1;
}
END

LOAD_DIST(r, d)
 r = 0 .. dist->lmt-1
 d = 0 .. dist->lnt-1
 kn = %{ int k; int n = 0; for(k = 0; k < NB_TOKEN; k++) { if( rank_of_token(k) == r && device_of_token(k) == d ) { n++;} } return n; %}
: dist(r, d)

D <- dist(r, d)
  -> [ik = 0 .. kn-1] 1 ? D TOKEN_GPU(%{ int k; 
                                   int i = 0; 
                                   for(k = 0; k < NB_TOKEN; k++) { 
                                     if(rank_of_token(k) == r && device_of_token(k) == d) { 
                                        if(ik == i) 
                                          return k; 
                                        i++; 
                                     } 
                                   } 
                                   assert(0); 
                                   return -1; 
                                 %}, 0..1)

BODY
{
    /* nothing */
}   
END

TOKEN_GPU(k, l)
 k = 0 .. NB_TOKEN-1
 l = 0 .. 1
 r = %{ return rank_of_token(k); %}
 d = %{ return device_of_token(k); %}

: dist(r, d)

RW D <- D LOAD_DIST(r, d)
     -> dist(r, d)
RW T <- l == 0 ? T TOKEN_CPU(k)
     <- l == 1 ? T TOKEN_GPU(k, 0)
     -> l == 0 ? T TOKEN_GPU(k, 1)
     -> l == 1 && k < NB_TOKEN-1 ? T TOKEN_CPU(k+1)
     -> l == 1 && k == NB_TOKEN-1 ? T CHECK(0)

BODY [type=CUDA]
{
    cuda_pong_kernel(T, 2*k+l);
}
END

BODY [type=HIP]
{
    hip_pong_kernel(T, 2*k+l);
}
END

CHECK(k)
 k = 0 .. 0

: dist(0, 0)

READ T <- T TOKEN_GPU(NB_TOKEN-1, 1)

BODY
{
    int *tile = (int*)T;
    for(int i = 0; i < 2*NB_TOKEN; i++) {
        if(tile[i] != 3*i) {
            fprintf(stderr, "Error in element %d: expecting %d got %d\n", i, 3*i, tile[i]);
            (*NB_ERR)++;
        }
    }
    if(*NB_ERR) {
        fprintf(stderr, "Expected: ");
        for(int i = 0; i < 2*NB_TOKEN; i++) {
            fprintf(stderr, "%3d ", 3*i);
        }
        fprintf(stderr, "\nReceived: ");
        for(int i = 0; i < 2*NB_TOKEN; i++) {
            fprintf(stderr, "%3d ", tile[i]);
        }
        fprintf(stderr, "\n");
    }
}
END

extern "C" %{

#define NLOOP 8

typedef struct {
    int rank;
    int device;
} token_t;

static token_t *tokens;

int rank_of_token(int k)
{
    return tokens[k].rank;
}

int device_of_token(int k)
{
    return tokens[k].device;
}

int main( int argc, char** argv )
{
    parsec_ptg_pingpong_taskpool_t* tp;
    parsec_matrix_block_cyclic_t dist;
    parsec_arena_datatype_t adt;
    parsec_datatype_t dt;
    parsec_context_t *parsec;
    int nb_gpus = 0;
    int nb_token, rc;
    int world = 1;
    int rank = 0;
    int nb_err = 0;

#ifdef PARSEC_HAVE_MPI
    {
        int provided;
        MPI_Init_thread(NULL, NULL, MPI_THREAD_SERIALIZED, &provided);
        MPI_Comm_size(MPI_COMM_WORLD, &world);
        MPI_Comm_rank(MPI_COMM_WORLD, &rank);
    }
#endif

    parsec = parsec_init(-1, &argc, &argv);
    if( NULL == parsec ) {
       exit(-1);
    }

    /**
     * Build the gpu_devices that stores the parsec index of the different
     * GPUs available, and compute the number of GPUs available on this node
     */
    int *gpu_devices;
    for(unsigned int i = 0; i < parsec_nb_devices; i++) {
        parsec_device_module_t *dev = parsec_mca_device_get(i);
#if defined(PARSEC_HAVE_DEV_CUDA_SUPPORT)
        if( dev->type == PARSEC_DEV_CUDA )
            nb_gpus++;
#endif
#if defined(PARSEC_HAVE_DEV_HIP_SUPPORT)
        if( dev->type == PARSEC_DEV_HIP )
            nb_gpus++;
#endif
    }
    if(0 == nb_gpus) {
        if(0 == rank) {
            fprintf(stderr, "Warning: test disabled because there is no GPU detected with this run\n");
        }
        parsec_fini(&parsec);
        MPI_Finalize();
        return EXIT_SUCCESS; /* So that useless tests don't make the CI fail */
    }
    gpu_devices = (int*)malloc(sizeof(int)*nb_gpus);
    nb_gpus = 0;
    for(unsigned int i = 0; i < parsec_nb_devices; i++) {
        parsec_device_module_t *dev = parsec_mca_device_get(i);
#if defined(PARSEC_HAVE_DEV_CUDA_SUPPORT)
        if( dev->type == PARSEC_DEV_CUDA )
            gpu_devices[nb_gpus++] = i;
#endif
#if defined(PARSEC_HAVE_DEV_HIP_SUPPORT)
        if( dev->type == PARSEC_DEV_HIP )
            gpu_devices[nb_gpus++] = i;
#endif
    }

    /**
     * Build the token circulation plan
     */
    nb_token = NLOOP*nb_gpus*world;
    tokens = (token_t*)malloc(nb_token * sizeof(token_t));
    nb_token = 0;
    for(int l = 0; l < NLOOP; l++) {
        for(int r = 0; r < world; r++) {
            for(int d = 0; d < nb_gpus; d++) {
                tokens[nb_token].rank = r;
                tokens[nb_token].device = gpu_devices[d];
                nb_token++;
            }
        }
    }

    /**
     * Create the distribution that is used to force things to run on a specific device
     * To avoid creating an additional datatype, we allocate each tile of the dist matrix
     * big enough to store the token. But that matrix will not store tokens.
     */
    parsec_matrix_block_cyclic_init(&dist, PARSEC_MATRIX_FLOAT, PARSEC_MATRIX_TILE,
                                    rank, 
                                    2*nb_token, 1,
                                    world*2*nb_token, parsec_nb_devices,
                                    0, 0,
                                    world*2*nb_token, parsec_nb_devices,
                                    1, 1,
                                    1, 1,
                                    0, 0);
    assert((size_t)parsec_datadist_getsizeoftype(dist.super.mtype) >= sizeof(int));
    size_t distSize = (size_t)dist.super.nb_local_tiles *
                      (size_t)dist.super.bsiz *
                      (size_t)parsec_datadist_getsizeoftype(dist.super.mtype);
    dist.mat = parsec_data_allocate(distSize);
    memset(dist.mat, 0, distSize);
    parsec_translate_matrix_type(PARSEC_MATRIX_FLOAT, &dt);
    parsec_add2arena(&adt, dt, PARSEC_MATRIX_FULL, 1, dist.super.mb, dist.super.nb, dist.super.mb, PARSEC_ARENA_ALIGNMENT_SSE, -1);

    /**
     * Set which device is preferred for each tile of dist, so the PTG / token plan can
     * define which device will hold which token
     */
    for(int d = 0; d < (int)parsec_nb_devices; d++) {
        parsec_data_t *dta = dist.super.super.data_of(&dist.super.super, rank, d);
        parsec_advise_data_on_device(dta, d, PARSEC_DEV_DATA_ADVICE_PREFERRED_DEVICE);
    }

    /* Start the PaRSEC engine */
    rc = parsec_context_start(parsec);
    PARSEC_CHECK_ERROR(rc, "parsec_context_start");

    tp = parsec_ptg_pingpong_new( (parsec_tiled_matrix_t *)&dist, nb_token, &nb_err );
    assert( NULL != tp );
    tp->arenas_datatypes[PARSEC_ptg_pingpong_DEFAULT_ADT_IDX] = adt;

    rc = parsec_context_add_taskpool( parsec, (parsec_taskpool_t*)tp );
    PARSEC_CHECK_ERROR(rc, "parsec_context_add_taskpool");
    rc = parsec_context_wait(parsec);
    parsec_taskpool_free(&tp->super);
    PARSEC_CHECK_ERROR(rc, "parsec_context_wait");

    free(dist.mat);
    parsec_del2arena( & adt );

    parsec_fini( &parsec);

#ifdef PARSEC_HAVE_MPI
    MPI_Finalize();
#endif

    return nb_err == 0 ? EXIT_SUCCESS : EXIT_FAILURE;
}


%}
