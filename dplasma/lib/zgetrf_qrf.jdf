extern "C" %{
/*
 *  Copyright (c) 2012
 *
 *  The University of Tennessee and The University
 *  of Tennessee Research Foundation.  All rights
 *  reserved.
 *
 * @precisions normal z -> s d c
 *
 */
#define PRECISION_z

#include "dague.h"
#include <math.h>
#include <plasma.h>
#include <core_blas.h>

#include <lapacke.h>

#include "data_distribution.h"
#include "data_dist/matrix/precision.h"
#include "data_dist/matrix/matrix.h"
#include "dplasma/lib/memory_pool.h"
#include "dplasma/lib/dplasmajdf.h"
#include "dplasma_qr_pivgen.h"
#include "dplasma/cores/dplasma_zcores.h"

PLASMA_desc plasma_desc_init(PLASMA_enum dtyp, int mb, int nb, int bsiz,
                             int lm, int ln, int i, int j, int m, int n);

#define FOLLOW_CONDNUM
%}

descA   [type = "tiled_matrix_desc_t"]
A       [type = "dague_ddesc_t *"]
IPIV    [type = "dague_ddesc_t *" aligned=A]
descSAV [type = "tiled_matrix_desc_t"]
SAV     [type = "dague_ddesc_t *" aligned=A]
descLT  [type = "tiled_matrix_desc_t"]
LT      [type = "dague_ddesc_t *" aligned=A]
lu_tab  [type = "int*"]
pivfct  [type = "qr_piv_t*"]
ib      [type = "int"]
p_work  [type = "dague_memory_pool_t *" size = "(sizeof(PLASMA_Complex64_t)*ib*(descLT.nb))"]
p_tau   [type = "dague_memory_pool_t *" size = "(sizeof(PLASMA_Complex64_t)   *(descLT.nb))"]
INFO    [type = "int*"]

param_p [type = int default="pivfct->p"      hidden=on]
param_a [type = int default="pivfct->a"      hidden=on]
param_d [type = int default="pivfct->domino" hidden=on]



/*===========================================================================================

                                       LU PART

===========================================================================================*/

/********************************************************************************************
 *
 *                                   GETRF kernel
 *
 * There are dplasma_qr_getnbgeqrf( pivfct, k, descA.mt ) getrf applyed at step
 * k on the block of rows indexed from m to m + s * param_p with a step of param_p. (1<=s<=param_a)
 * nextm is the first row that will be killed by the row m at step k.
 * nextm = descA.mt if the row m is never used as a killer.
 *
 ********************************************************************************************/

zgetrf(k)
  /* Execution space */
  k = 0..( (descA.mt < descA.nt) ? descA.mt-1 : descA.nt-1 )

  : A(k, k)

  RW    A    <-  A selector(k,k,k)
             -> A zgetrf_typechange(k)
             -> ( k == (descA.mt-1) ) ? A(k, k)                                                  [type = UPPER_TILE]
             -> ( k <  (descA.mt-1) ) ?  A ztrsm_l(k, k+1..descA.mt)                             [type = UPPER_TILE]
  RW    IP   <- IP selector(k,k,k)                                                               [type = PIVOT]
             -> IPIV(k, k)                                                                       [type = PIVOT]
             -> (k < descA.nt-1) ? IP swptrsm_u(k, (k+1)..(descA.nt-1))                          [type = PIVOT]

; descA.nt-k-1
BODY
  /* Nothing (LU factorization already done by lu_facto)*/
END


zgetrf_typechange(k) [profile = off]
  /* Execution space */
  k = 0..( (descA.mt < descA.nt) ? descA.mt-1 : descA.nt-1 )

  : A(k, k)

  RW A <- A zgetrf(k)
       -> ( descA.nt-1 > k ) ? A swptrsm_u(k, (k+1)..(descA.nt-1))      [type = LOWER_TILE]
       -> A(k, k)                                                       [type = LOWER_TILE]

  CTL ctl -> ctl ztrsm_l(k, (k+1)..(descA.nt-1))

; descA.nt-k-1
BODY
    /* Nothing */
END


/********************************************************************************************
 *
 *                               SWAP + TRSM
 *
 ********************************************************************************************/

swptrsm_u(k, n)
  /* Execution space */
  k = 0..( ( descA.mt < descA.nt ) ? descA.mt-1 : descA.nt-1)
  n = k+1..descA.nt-1

  did_lu = inline_c %{ return lu_tab[k-1]; %}
  s      = inline_c %{ return ceil((descA.mt-k)/param_p); %}
  ks     = inline_c %{ return k + (s-1)*param_p; %}

  /* Locality */
  : A(k, n)

  READ  A    <- A  zgetrf_typechange(k,k,k)                                                       [type = LOWER_TILE]
  READ  IP   <- IP zgetrf(k)                                                                       [type = PIVOT]
  RW    C    <- A selector(k, k, n )
             -> A(k, n)
             -> ( k <  (descA.mt-1) ) ? V zgemm(k, (k+1)..(descA.mt-1), n)  
  CTL   ctl  <- ( k > 0 )  ? ctl tile2panel(k-1, k, n )


/* Priority */
;descA.nt-n-1

BODY
{
    int tempkm = (k == (descA.mt-1)) ? (descA.m - k * descA.mb) : descA.mb;
    int tempnn = (n == (descA.nt-1)) ? (descA.n - n * descA.nb) : descA.nb;
    int tempm  = (s-1) * descA.mb +
        (( ks == descA.mt-1 ) ? descA.m - ks * descA.mb : descA.mb);
    int ldak = BLKLDD(descA, k);

    printlog("\nthread %d VP %d zswptrsm_hpp",
             context->th_id, context->virtual_process->vp_id);

    DRYRUN(

        PLASMA_desc pdescA = plasma_desc_init( PlasmaComplexDouble,
                                               descA.mb, descA.nb, descA.mb * descA.nb,
                                               s*descA.mb, descA.nb, 0, 0,
                                               tempm, tempnn );
        pdescA.mat = (void*)C;

        CORE_zlaswp_ontile( pdescA, 1, tempkm, IP, 1 );

        CORE_ztrsm(
            PlasmaLeft, PlasmaLower, PlasmaNoTrans, PlasmaUnit,
            tempkm, tempnn,
            1., A /*A(m, k)*/, ldak,
                C /*A(m, n)*/, ldak);
           );
}
END


/********************************************************************************************
 *
 *                                 TRSM kernel
 *
 ********************************************************************************************/

ztrsm_l(k, m)
  /* Execution space */
  k = 0..( (descA.mt < descA.nt) ? descA.mt-1 : descA.nt-1 )
  m = k+1..descA.mt-1

  s     = inline_c %{ return ceil((descA.mt-k)/param_p); %}
  type  = inline_c %{ return ((m-k)%param_p == 0) ? 0 : 1; %}

  : A(m, k)

  READ A  <- (type != 0 ) ? A zgetrf(k)                                                                 [type = UPPER_TILE]

  RW   C  <- A selector(k, m, k)
          -> A(m, k)
          -> ( k < (descA.nt-1) ) ? H zgemm(k, m, (k+1)..(descA.nt-1))

  CTL ctl <- ctl zgetrf_typechange(k)

; descA.nt-k-1
BODY
{
    int tempmm = ((m)==((descA.mt)-1)) ? ((descA.m)-(m*(descA.mb))) : (descA.mb);
    int tempkm = ((k)==((descA.mt)-1)) ? ((descA.m)-(k*(descA.mb))) : (descA.mb);
    int ldam = BLKLDD( descA, m );
    int ldak = BLKLDD( descA, k );

    printlog("CORE_trsm_L(k=%d,m=%d,ldk=%d,ldm=%d,A(%d,%d))\n", tempkm, tempmm,ldak,ldam,m,k);

    DRYRUN(
         if ( type == 0 ) {
             /* TRSM already applied by GETRF */
         } else {
            CORE_ztrsm(
                PlasmaRight, PlasmaUpper, PlasmaNoTrans, PlasmaNonUnit,
                tempmm,
                tempkm,
                1.0, A /*A(k, k)*/, ldak,
                C /*A(m, k)*/, ldam );
         }
           );
}
END



/********************************************************************************************
 *
 *                                 GEMM kernel
 *
 ********************************************************************************************/

zgemm(k, m, n)
  /* Execution space */
  k = 0..( (descA.mt < descA.nt) ? descA.mt-1 : descA.nt-1 )
  m = k+1..descA.mt-1
  n = k+1..descA.nt-1

  s     = inline_c %{ return ceil((descA.mt-k)/param_p); %}
  type  = inline_c %{ return ((m-k)%param_p == 0) ? 0 : 1; %}

  : A(m, n)

  READ V  <- C swptrsm_u(k, n)

  READ  H <- C ztrsm_l(k, m)

  RW   C  <- A selector(k, m, n)
          -> ((m == k+1) && (n == k+1)) ? A zlufacto(k+1) : A selector(k+1, m, n)

  CTL ctl  -> ( type == 0 ) ? ctl tile2panel(k, m, n)

; descA.nt-n-1
BODY
{
    int tempnn = ((n)==((descA.nt)-1)) ? ((descA.n)-(n*(descA.nb))) : (descA.nb);
    int tempmm = ((m)==((descA.mt)-1)) ? ((descA.m)-(m*(descA.mb))) : (descA.mb);
    int ldam = BLKLDD( descA, m );
    int ldak = BLKLDD( descA, k );

    printlog("\nthread %d VP %d zgemm( k=%d, m=%d, n=%d, p=%d, nextp=%d, prevp=%d, prevm=%d, type=%d, nexttype=%d, ip=%d, im=%d, nextim=%d)\n"
             "\t(M1=%d, N1=%d, M2=%d, N2=%d, ib=%d, \n"
             "\t A1(%d,%d)[%p], lda1=%d, A2(%d,%d)[%p], lda2 = %d,\n"
             "\t LT(%d,%d)[%p], descLT.mb=%d, A(%d,%d)[%p], lda = %d)\n",
             context->th_id, context->virtual_process->vp_id, k, m, n, p, nextp, prevp, prevm, type, nexttype, ip, im, nextim,
             descA.mb, tempnn, tempmm, tempnn, ib,
             p, n, V, ldap, m, n, C, ldam,
             m, k, T, descLT.mb, m, k, H, ldam);

    DRYRUN(
         if ( type == 0 ) { 
             /* GEMM already applied by SWPTRSM */
         } else {
             CORE_zgemm(PlasmaNoTrans, PlasmaNoTrans,
                   tempmm, tempnn, descA.mb,
                   -1., V /*(m, k)*/, ldam,
                        H /*(k, n)*/, ldak,
                   1.,  C /*(m, n)*/, ldam );
         }
           );
}
END


/*==========================================================================================

                                   QR PART

===========================================================================================*/

/*****************************************************************************************
 * GEQRT kernel
 *
 * There are dplasma_qr_getnbgeqrf( pivfct, k, descA.mt ) geqrt applyed at step
 * k on the rows indexed by m.
 * nextm is the first row that will be killed by the row m at step k.
 * nextm = descA.mt if the row m is never used as a killer.
 *
 *****************************************************************************************/
zgeqrt(k, i)
  /* Execution space */
  k = 0..( (descA.mt < descA.nt) ? descA.mt-1 : descA.nt-1 )
  i = 0..inline_c %{ return dplasma_qr_getnbgeqrf( pivfct, k, descA.mt ) - 1; %}
  m = inline_c %{ return dplasma_qr_getm( pivfct, k, i); %}
  nextm = inline_c %{ return dplasma_qr_nextpiv( pivfct, m, k, descA.mt); %}

  SIMCOST 4

  : A(m, k)

  /* A == A(m, k) */
  /* T == T(m, k) */

  RW    A <- A selector(k, m, k )
          -> A zgeqrt_typechange(k, i)
          //-> (descA.nt-1 > k) ? A zunmqr(k, i, (k+1)..(descA.nt-1))
          -> ( k == descA.mt-1 ) ? A(m, k)                                     [type = UPPER_TILE]
          -> ( (k < descA.mt-1) & (nextm != descA.mt) ) ?  A1 zttqrt(k, nextm) [type = UPPER_TILE]
          -> ( (k < descA.mt-1) & (nextm == descA.mt) ) ?  A2 zttqrt(k, m)     [type = UPPER_TILE]
  RW    T <- LT(m, k)                                                           [type = LITTLE_T]
          -> LT(m, k)                                                           [type = LITTLE_T]
          -> (descA.nt-1 > k) ? T zunmqr(k, i, (k+1)..(descA.nt-1))            [type = LITTLE_T]

  ; descA.nt-k-1

BODY
  int tempmm = (m==(descA.mt-1)) ? (descA.m - m * descA.mb) : descA.mb;
  int tempkn = (k==(descA.nt-1)) ? (descA.n - k * descA.nb) : descA.nb;
  int ldam   = BLKLDD( descA, m );

  DRYRUN(
         void *p_elem_A = dague_private_memory_pop( p_tau  );
         void *p_elem_B = dague_private_memory_pop( p_work );

         CORE_zgeqrt(tempmm, tempkn, ib,
                     A /* A(m,k) */, ldam,
                     T /* T(m,k) */, descLT.mb,
                     p_elem_A, p_elem_B );

         dague_private_memory_push( p_tau, p_elem_A );
         dague_private_memory_push( p_work, p_elem_B );

         );

#if defined(DAGUE_SIM)
  if ( descA.mt-1 == k )
    ((PLASMA_Complex64_t*)A)[0] = (PLASMA_Complex64_t)(this_task->sim_exec_date);
#endif
  printlog("thread %d VP %d CORE_zgeqrt(%d, %d)\n"
           "\t(tempmm, tempkn, ib, A(%d,%d)[%p], ldam, T(%d,%d)[%p], descLT.mb, p_elem_A, p_elem_B)\n",
           context->th_id, context->virtual_process->vp_id, k, m, m, k, A, m, k, T);

END


zgeqrt_typechange(k, i) [profile = off]
  /* Execution space */
  k = 0..( (descA.mt < descA.nt) ? descA.mt-1 : descA.nt-1 )
  i = 0..inline_c %{ return dplasma_qr_getnbgeqrf( pivfct, k, descA.mt ) - 1; %}
  m = inline_c %{ return dplasma_qr_getm( pivfct, k, i); %}

  : A(m, k)

  RW A <- A zgeqrt(k, i)
       -> ( descA.nt-1 > k ) ? A zunmqr(k, i, (k+1)..(descA.nt-1)) [type = LOWER_TILE]
       -> A(m, k)                                                  [type = LOWER_TILE]
BODY
 /* Nothing */
END


/*
 * UNMQR (see GEQRT)
 */
zunmqr(k, i, n)
  /* Execution space */
  k = 0..( ( descA.mt < descA.nt ) ? descA.mt-1 : descA.nt-1)
  i = 0..inline_c %{ return dplasma_qr_getnbgeqrf( pivfct, k, descA.mt ) - 1; %}
  n = k+1..descA.nt-1
  m = inline_c %{ return dplasma_qr_getm( pivfct, k, i); %}
  nextm = inline_c %{ return dplasma_qr_nextpiv( pivfct, m, k, descA.mt); %}

  SIMCOST 6

  : A(m, n)

  /* A == A(m,k) */
  /* T == T(m,k) */
  /* C == A(m,n) */

  READ  A <- A zgeqrt_typechange(k, i)                              [type = LOWER_TILE]
  READ  T <- T zgeqrt(k, i)                                         [type = LITTLE_T]
  RW    C <- A selector(k, m, n)
          -> ( k == descA.mt-1 ) ? A(m, n)
          -> ( (k < descA.mt-1) & (nextm != descA.mt) ) ? A1 zttmqr(k, nextm, n)
          -> ( (k < descA.mt-1) & (nextm == descA.mt) ) ? A2 zttmqr(k, m,     n)

    ; descA.nt-n-1

BODY
  DRYRUN(
         void *p_elem_A = dague_private_memory_pop( p_work );

         int tempmm = (m == (descA.mt-1)) ? (descA.m - m * descA.mb) : descA.mb;
         int tempnn = (n == (descA.nt-1)) ? (descA.n - n * descA.nb) : descA.nb;
         int ldam   = BLKLDD( descA, m );

         CORE_zunmqr(
                     PlasmaLeft, PlasmaConjTrans,
                     tempmm, tempnn, tempmm, ib,
                     A /* A(m, k) */, ldam,
                     T /* T(m, k) */, descLT.mb,
                     C /* A(m, n) */, ldam,
                     p_elem_A, descLT.nb );

         dague_private_memory_push( p_work, p_elem_A );
         );

  printlog("thread %d VP %d CORE_zunmqr(%d, %d, %d)\n"
           "\t(PlasmaLeft, PlasmaConjTrans, tempmm, tempnn, min(tempmm, tempnn), ib, \n"
           "\t A(%d,%d)[%p], ldam, T(%d,%d)[%p], descLT.mb, A(%d,%d)[%p], ldam, p_elem_A, descLT.nb)\n",
           context->th_id, context->virtual_process->vp_id, k, m, n, m, k, A, m, k, T, m, n, C);

END


zttqrt_out_A1(k) [profile = off]
  k = 0..( (descA.mt <= descA.nt) ? descA.mt-2 : descA.nt-1 )
  prevp = inline_c %{ return dplasma_qr_prevpiv(pivfct, k, k, k); %}

  : A(k, k)

  RW A <- A1 zttqrt( k, prevp ) [type = UPPER_TILE]
       -> A(k, k)               [type = UPPER_TILE]
BODY
/* nothing */
END


/******************************************************************************************
 * TTQRT kernel
 *
 * The row p kills the row m.
 * nextp is the row that will be killed by p at next stage of the reduction.
 * prevp is the row that has been killed by p at the previous stage of the reduction.
 * prevm is the row that has been killed by m at the previous stage of the reduction.
 * type defines the operation to perform: TS if 0, TT otherwise
 * ip is the index of the killer p in the sorted set of killers for the step k.
 * im is the index of the killer m in the sorted set of killers for the step k.
 *
 *****************************************************************************************/

zttqrt(k, m)
  /* Execution space */
  k = 0..( (descA.mt < descA.nt) ? descA.mt-1 : descA.nt-1 )
  m = k+1..descA.mt-1
  p =     inline_c %{ return dplasma_qr_currpiv(pivfct, m, k); %}
  nextp = inline_c %{ return dplasma_qr_nextpiv(pivfct, p, k, m); %}
  prevp = inline_c %{ return dplasma_qr_prevpiv(pivfct, p, k, m); %}
  prevm = inline_c %{ return dplasma_qr_prevpiv(pivfct, m, k, m); %}
  type  = inline_c %{ return dplasma_qr_gettype( pivfct, k, m ); %}
  ip    = inline_c %{ return dplasma_qr_geti(    pivfct, k, p ); %}
  im    = inline_c %{ return dplasma_qr_geti(    pivfct, k, m ); %}

  SIMCOST inline_c %{ return type == DPLASMA_QR_KILLED_BY_TS ? 6 : 2; %}

  : A(m, k)

  /* A1 == A(p,  k) */
  /* A2 == A(m,  k) */
  /* T  == T2(m, k) */

  RW   A1 <- (   prevp == descA.mt ) ? A  zgeqrt(k, ip ) : A1 zttqrt(k, prevp ) [type = UPPER_TILE]
          -> (   nextp != descA.mt ) ? A1 zttqrt(k, nextp )                     [type = UPPER_TILE]
          -> ( ( nextp == descA.mt ) & (p == k) ) ? A zttqrt_out_A1(k)          [type = UPPER_TILE]
          -> ( ( nextp == descA.mt ) & (p != k) ) ? A2 zttqrt(k, p)             [type = UPPER_TILE]
  RW   A2 <- (type == 0)                             ? A selector(k, m, k )     /* type 0 = DPLASMA_QR_KILLED_BY_TS */
          <- ( (type != 0) && (prevm == descA.mt ) ) ? A  zgeqrt(k, im )        /* type 0 = DPLASMA_QR_KILLED_BY_TS */
          <- ( (type != 0) && (prevm != descA.mt ) ) ? A1 zttqrt(k, prevm )     /* type 0 = DPLASMA_QR_KILLED_BY_TS */
          -> A(m, k)
          -> (descA.nt-1 > k)? V zttmqr(k, m, (k+1)..(descA.nt-1))
  RW   T  <- LT(m, k)                                              [type = LITTLE_T]
          -> LT(m, k)                                              [type = LITTLE_T]
          -> (descA.nt-1 > k)? T zttmqr(k, m, (k+1)..(descA.nt-1)) [type = LITTLE_T]

 ; descA.nt-k-1

BODY
  int tempmm = ((m)==((descA.mt)-1)) ? ((descA.m)-(m*(descA.mb))) : (descA.mb);
  int tempkn = ((k)==((descA.nt)-1)) ? ((descA.n)-(k*(descA.nb))) : (descA.nb);
  int ldap = BLKLDD( descA, p );
  int ldam = BLKLDD( descA, m );

  DRYRUN(
         void *p_elem_A = dague_private_memory_pop( p_tau  );
         void *p_elem_B = dague_private_memory_pop( p_work );

         if ( type == DPLASMA_QR_KILLED_BY_TS ) {
           CORE_ztsqrt(
                     tempmm, tempkn, ib,
                     A1 /* A(p, k) */, ldap,
                     A2 /* A(m, k) */, ldam,
                     T  /* T(m, k) */, descLT.mb,
                     p_elem_A, p_elem_B );
         } else {
           CORE_zttqrt(
                     tempmm, tempkn, ib,
                     A1 /* A(p, k) */, ldap,
                     A2 /* A(m, k) */, ldam,
                     T  /* T(m, k) */, descLT.mb,
                     p_elem_A, p_elem_B );
         }
         dague_private_memory_push( p_tau , p_elem_A );
         dague_private_memory_push( p_work, p_elem_B );

         );

#if defined(DAGUE_SIM)
  ((PLASMA_Complex64_t*)A2)[0] = (PLASMA_Complex64_t)(this_task->sim_exec_date);
  if ( ( ( nextp == descA.mt ) & (p == k) ) )
    ((PLASMA_Complex64_t*)A1)[0] = (PLASMA_Complex64_t)(this_task->sim_exec_date);
#endif
  printlog("thread %d VP %d CORE_zttqrt(%d, %d)\n"
           "\t(tempmm, tempkn, ib, A(%d,%d)[%p], A.mb, A(%d,%d)[%p], ldam, T(%d,%d)[%p], descLT.mb, p_elem_A, p_elem_B)\n",
           context->th_id, context->virtual_process->vp_id, k, m, p, k, A1, m, k, A2, m, k, T);

END


zttmqr_out_A1(k, n) [profile = off]
  k = 0..( (descA.mt < descA.nt) ? descA.mt-2 : descA.nt-2 )
  n = k+1..descA.nt-1
  prevp = inline_c %{ return dplasma_qr_prevpiv(pivfct, k, k, k); %}

  : A(k, n)

  RW A <- A1 zttmqr( k, prevp, n )
       -> A(k, n)
BODY
/* nothing */
END


/***********************************************************************************************
 * TTMQR kernel (see TTQRT)
 *
 * type1 defines the operations to perfom at next step k+1 on the row m
 *   if type1 == 0, it will be a TS so the tile goes to a TTQRT/TTMQR operation
 *   if type1 != 0, it will be a TT so the tile goes to a GEQRT/UNMQR operation
 * im1 is the index of the killer m at the next step k+1 if its type is !0, descA.mt otherwise
 *
 **********************************************************************************************/

zttmqr(k, m, n)
  /* Execution space */
  k = 0..( (descA.mt < descA.nt) ? descA.mt-1 : descA.nt-1 )
  m = k+1..descA.mt-1
  n = k+1..descA.nt-1
  p =     inline_c %{ return dplasma_qr_currpiv(pivfct, m, k); %}
  nextp = inline_c %{ return dplasma_qr_nextpiv(pivfct, p, k, m); %}
  prevp = inline_c %{ return dplasma_qr_prevpiv(pivfct, p, k, m); %}
  prevm = inline_c %{ return dplasma_qr_prevpiv(pivfct, m, k, m); %}
  type  = inline_c %{ return dplasma_qr_gettype( pivfct, k,   m ); %}
  type1 = inline_c %{ return dplasma_qr_gettype( pivfct, k+1, m ); %}
  ip    = inline_c %{ return dplasma_qr_geti(    pivfct, k,   p ); %}
  im    = inline_c %{ return dplasma_qr_geti(    pivfct, k,   m ); %}
  im1   = inline_c %{ return dplasma_qr_geti(    pivfct, k+1, m ); %}

  SIMCOST inline_c %{ return type == DPLASMA_QR_KILLED_BY_TS ? 12 : 6; %}

  : A(m, n)

  /* A1 == A(p, n) */
  /* A2 == A(m, n) */
  /* V  == A(m, k) */
  /* T  == T(m, k) */

  RW   A1 <- (   prevp == descA.mt ) ? C  zunmqr( k, ip, n ) : A1 zttmqr(k, prevp, n )
          -> (   nextp != descA.mt ) ? A1 zttmqr( k, nextp, n)
          -> ( ( nextp == descA.mt ) & ( p == k ) ) ? A zttmqr_out_A1(p, n)
          -> ( ( nextp == descA.mt ) & ( p != k ) ) ? A2 zttmqr( k, p, n )
  RW   A2 <- (type  == 0 )                           ? A selector(k, m, n )      /* type 0 = DPLASMA_QR_KILLED_BY_TS */
          <- ( (type  != 0 ) && (prevm == descA.mt ) ) ? C  zunmqr(k, im, n)       /* type 0 = DPLASMA_QR_KILLED_BY_TS */
          <- ( (type  != 0 ) && (prevm != descA.mt ) ) ? A1 zttmqr(k, prevm, n )   /* type 0 = DPLASMA_QR_KILLED_BY_TS */
          -> ((m == k+1) && (n == k+1)) ? A zlufacto(k+1) : A selector(k+1, m, n)

  READ  V <- A2 zttqrt(k, m)
  READ  T <- T  zttqrt(k, m) [type = LITTLE_T]

  CTL ctl  -> ( type == 0 ) ? ctl tile2panel(k, m, n)

    ; descA.nt-n-1

BODY
  int tempnn = ((n)==((descA.nt)-1)) ? ((descA.n)-(n*(descA.nb))) : (descA.nb);
  int tempmm = ((m)==((descA.mt)-1)) ? ((descA.m)-(m*(descA.mb))) : (descA.mb);
  int ldap = BLKLDD( descA, p );
  int ldam = BLKLDD( descA, m );
  int ldwork = ib;

  DRYRUN(
         void *p_elem_A = dague_private_memory_pop( p_work );

         if ( type == DPLASMA_QR_KILLED_BY_TS ) {
           CORE_ztsmqr(
             PlasmaLeft, PlasmaConjTrans,
             descA.mb, tempnn, tempmm, tempnn, descA.nb, ib,
             A1 /* A(p, n) */, ldap,
             A2 /* A(m, n) */, ldam,
             V  /* A(m, k) */, ldam,
             T  /* T(m, k) */, descLT.mb,
             p_elem_A, ldwork );
         } else {
           CORE_zttmqr(
             PlasmaLeft, PlasmaConjTrans,
             descA.mb, tempnn, tempmm, tempnn, descA.nb, ib,
             A1 /* A(p, n) */, ldap,
             A2 /* A(m, n) */, ldam,
             V  /* A(m, k) */, ldam,
             T  /* T(m, k) */, descLT.mb,
             p_elem_A, ldwork );
         }
         dague_private_memory_push( p_work, p_elem_A );

         );

  printlog("thread %d VP %d CORE_zttmqr(%d, %d, %d)\n"
           "\t(PlasmaLeft, PlasmaConjTrans, descA.mb, tempnn, tempmm, tempnn, descA.nb, ib, \n"
           "\t A(%d,%d)[%p], A.mb, A(%d,%d)[%p], ldam, A(%d,%d)[%p], ldam, T(%d,%d)[%p], descLT.mb, p_elem_A, ldwork)\n",
           context->th_id, context->virtual_process->vp_id, k, m, n, p, n, A1, m, n, A2, m, k, V, m, k, T);

END


/*==========================================================================================

                                   CHOICE PART

===========================================================================================*/


/************************************************************************************
 *                      Tile 2 panel (Forward)                                      *
 *         Insure that step k on panel n is done before to start step k+1           *
 ************************************************************************************/

tile2panel(k, m, n) [ profile = off ]
  k = 0..( (descA.mt < descA.nt) ? descA.mt-1 : descA.nt-1 )
  m = k+1..descA.mt-1
  n = k+1..descA.nt-1

  type     = inline_c %{ return dplasma_qr_gettype( pivfct, k,   m ); %}
  nexttype = inline_c %{ return dplasma_qr_gettype( pivfct, k+1, m ); %}
  p        = inline_c %{ return nexttype == 0 ? dplasma_qr_currpiv(pivfct, m, k+1 ) : m; %}
  i        = inline_c %{ return dplasma_qr_geti( pivfct, k+1, p ); %}
  s        = inline_c %{ return dplasma_qr_getsize( pivfct, k+1, i ); %}
  ms       = inline_c %{ return p + (s-1)*param_p; %}
  did_lu   = inline_c %{ return lu_tab[k]; %}

  :A(m, n)

  CTL  ctli <- (m < ms) ? ctli tile2panel(k, m+param_p, n)
            -> (m > p ) ? ctli tile2panel(k, m-param_p, n)

  CTL  ctl  <- ( (type == 0) && (did_lu == 1) ) ? ctl zgemm(k, m, n)
            <- ( (type == 0) && (did_lu != 1) ) ? ctl zttmqr(k, m, n)
            /* Protect step k+1 */
            -> ( (m == p) & (n == k+1) ) ? ctl zlufacto(k+1)
            -> ( (m == p) & (n >  k+1) ) ? ctl swptrsm_u(k+1, n)

  ;descA.nt-n-1
BODY
    printlog("\nthread %d VP %d tile2panel( k = %d, m = %d, n = %d ) type = %d\n", context->th_id, context->virtual_process->vp_id, k, m, n, type);
END


zlufacto(k)
 /* Execution space */
  k = 0..( (descA.mt < descA.nt) ? descA.mt-1 : descA.nt-1 )
  did_lu = inline_c %{ return lu_tab[k-1]; %}
  s      = inline_c %{ return ceil((descA.mt-k)/param_p); %}
  ks     = inline_c %{ return k + (s-1)*param_p; %}

  : A(k, k)

  RW    A    <- (k == 0) ? A(k,k)
             <- ((k!=0)&&(did_lu == 1)) ? C zgemm(k-1,k,k) 
             <- ((k!=0)&&(did_lu != 1)) ? A2 zttmqr(k-1,k,k)
			 -> A zsetchoice(k)

  RW    IP   <- IPIV(k, k)                                                                       [type = PIVOT]
             -> IPIV(k, k)                                                                       [type = PIVOT]
             -> IP zsetchoice(k)										                         [type = PIVOT]

  RW    SAV  <- SAV(k, k)
             -> SAV zsetchoice(k)

  CTL   ctl  <- ( k != 0 ) ? ctl tile2panel(k-1,k,k) 
            
; descA.nt-k-1
BODY
{
    /* Copy A in SAV and do the LU factorization on A */ 

    int iinfo = 0;
    int tempn = (k == (descA.nt-1)) ? (descA.n - k * descA.nb) : descA.nb;
    int tempm = (s-1) * descA.mb +
        (( ks == descA.mt-1 ) ? descA.m - ks * descA.mb : descA.mb);
    int ldak = BLKLDD( descA, k );
    int ldsavk = BLKLDD( descSAV, k );

    printlog("\nthread %d VP %d zlufacto( k=%d)\n",
             context->th_id, context->virtual_process->vp_id, k);

    DRYRUN(
        /* Set local IPIV to 0 before generation
         * Better here than a global initialization for locality
         * and it's also done in parallel */

		CORE_zlacpy(PlasmaUpperLower, s*descA.mb, descA.nb,
                    A, ldak,
                    SAV, ldsavk);

        memset(IP, 0, dague_imin(tempn, tempm) * sizeof(int) );

        PLASMA_desc pdescA = plasma_desc_init( PlasmaComplexDouble,
                                               descA.mb, descA.nb, descA.mb * descA.nb,
                                               s*descA.mb, descA.nb, 0, 0,
                                               tempm, tempn );
        pdescA.mat = A;

        iinfo = CORE_zgetrf_rectil_1thrd( pdescA, IP );

        if ( iinfo != 0 ) {
            *INFO = k * descA.mb + iinfo; /* Should return if enter here */
            fprintf(stderr, "zlufacto(%d) failed => %d\n", k, *INFO );
        }
           );
}
END   


zsetchoice(k)
 /* Execution space */
  k = 0..( (descA.mt < descA.nt) ? descA.mt-1 : descA.nt-1 )
  s      = inline_c %{ return ceil((descA.mt-k)/param_p); %}
  ks     = inline_c %{ return k + (s-1)*param_p; %}

  : A(k, k)

  RW    A    <- A zlufacto(k)
			 -> A selector(k,k,k)

  RW    IP   <- IP zlufacto(k)                                                                     [type = PIVOT]
			 -> IP selector(k,k,k)												                   [type = PIVOT]

  RW    SAV  <- SAV zlufacto(k)
             -> SAV(k,k)


; descA.nt-k-1
BODY
{
    /* On r√©colte les conditions number et on fait le choix */

    int ldak = BLKLDD( descA, k );
    int ldsavk = BLKLDD( descSAV, k );

    DRYRUN(
         int cond = 0;

         cond = rand() % 2;

         if (cond == 1)
             lu_tab[k] = 1;
         else{
             lu_tab[k] = 0;

             CORE_zlacpy(PlasmaUpperLower, s*descA.mb, descA.nb,
                    SAV, ldsavk,
                    A, ldak);
             }
          );
}
END  


selector(k,m,n)
 /* Execution space */
  k = 0..( (descA.mt < descA.nt) ? descA.mt-1 : descA.nt-1 )
  m = k..descA.mt-1
  n = k..descA.nt-1
  i    = inline_c %{ return dplasma_qr_geti(    pivfct, k,   m ); %}
  type  = inline_c %{ return dplasma_qr_gettype( pivfct, k,   m ); %}
  did_lu = inline_c %{ return lu_tab[k-1]; %}
  do_lu = inline_c %{ return lu_tab[k]; %}

  : A(m,n)

  RW    A   <- ( k==0 ) ? A(m,n)
            <- ( ((k!=0)&&(did_lu == 1))&&((k==m)&&(k==n)) ) ? A zsetchoice(k)
            <- ( (k!=0)&&(did_lu == 1)&&(k!=m)         ) ? C zgemm(k-1,m,n)
            <- ( (k!=0)&&(did_lu == 1)&&(k!=n)         ) ? C zgemm(k-1,m,n)
            <- ( (k!=0)&&(did_lu != 1)&&(k==m)&&(k==n) ) ? A zsetchoice(k)
            <- ( (k!=0)&&(did_lu != 1)&&(k!=m)         ) ? A2 zttmqr(k-1,m,n)
            <- ( (k!=0)&&(did_lu != 1)&&(k!=n)         ) ? A2 zttmqr(k-1,m,n)
            -> ( (do_lu == 1)&&(k==n)&&(k==m)    ) ? A zgetrf(k) 
            -> ( (do_lu == 1)&&(k==n)&&(k!=m)    ) ? C ztrsm_l(k,m)
            -> ( (do_lu == 1)&&(k!=n)&&(k==m)    ) ? C swptrsm_u(k,n)
            -> ( (do_lu == 1)&&(k!=n)&&(k!=m)    ) ? C zgemm(k,m,n)
            -> ( (do_lu == 0)&&(k==n)&&(type==0) ) ? A zgeqrt(k,i) 
            -> ( (do_lu == 0)&&(k==n)&&(type!=0) ) ? A2 zttqrt(k,m) 
            -> ( (do_lu == 0)&&(k!=n)&&(type==0) ) ? C zunmqr(k,i,n) 
            -> ( (do_lu == 0)&&(k!=n)&&(type!=0) ) ? A2 zttmqr(k,m,n) 

  RW    IP  <- ( (m==k)&&(n==k)&&(do_lu == 1) ) ? IP zsetchoice(k)
            -> ( (m==k)&&(n==k)&&(do_lu == 1) ) ? IP zgetrf(k)

  ; descA.nt-k-1
BODY
{
    /* Nothing */   
}
END  
