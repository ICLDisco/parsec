extern "C" %{
/*
 *  Copyright (c) 2010
 *
 *  The University of Tennessee and The University
 *  of Tennessee Research Foundation.  All rights
 *  reserved.
 *
 * @precisions normal z -> s d c
 *
 */
#define PRECISION_z

#include <plasma.h>
#include <core_blas.h>
#include <math.h>

#include "dague.h"
#include "data_distribution.h"
#include "data_dist/matrix/precision.h"
#include "data_dist/matrix/matrix.h"
#include "dplasma/lib/memory_pool.h"
#include "dplasma/lib/dplasmajdf.h"
#include "dplasma/cores/dplasma_zcores.h"


#define INIT 0
#define TEMP (descA.nb)
#define MAXI (descA.nb*2)
#define SRCH (descA.nb*3)
#define PIVO (descA.nb*4)

%}

/* Globals
 */
A            [type = "dague_ddesc_t *"]
IPIV         [type = "dague_ddesc_t *"]
V            [type = "dague_ddesc_t *"]
BUFFER       [type = "dague_ddesc_t *"]
ACOPY        [type = "dague_ddesc_t *"]
P            [type = "int"]
Q            [type = "int"]
INFO         [type = "int*"]

descA        [type = "tiled_matrix_desc_t" hidden=on default="*((tiled_matrix_desc_t*)A)" ]


/**************************************************
 *                    IP_in (pseudo task)
 **************************************************/
IP_in(k,m)

// Execution space
k = 0..((descA.mt<descA.nt)?descA.mt-1:descA.nt-1)
m = 0..((descA.mt<P)?(descA.mt-1):(P-1))

// Parallel partitioning
:IPIV((k+m)%P,k%Q)

// Parameters
READ  IP <- IPIV((k+m)%P,k%Q)                                                               [type = PIVOT]
         -> IP GETRF_FNL(k,(k+m)..(descA.mt-((descA.mt-k-m-1)%P)-1)..P)                         [type = PIVOT]

BODY
        /* Nothing to do */
END

/**************************************************
 *                    IP_out (pseudo task)
 **************************************************/
IP_out(k,m)

// Execution space
k = 0..((descA.mt<descA.nt)?descA.mt-1:descA.nt-1)
m = 0..((descA.mt<P)?(descA.mt-1):(P-1))

// Parallel partitioning
:IPIV((k+m)%P,k%Q)

// Parameters
READ  IP <- IP GETRF_FNL(k,k+m)                                                             [type = PIVOT]
         -> IPIV((k+m)%P,k%Q)                                                               [type = PIVOT]

BODY
        /* Nothing to do */
END


/**************************************************
 *                    V_in (pseudo task)
 **************************************************/
V_in(k,m)

// Execution space
k = 0..((descA.mt<descA.nt)?descA.mt-1:descA.nt-1)
m = 0..((descA.mt<P)?(descA.mt-1):(P-1))

// Parallel partitioning
:V((k+m)%P,k%Q)

// Parameters
READ  V <- V((k+m)%P,k%Q)                                       [type = SWAP]
        -> V GETRF_MAX(k,k+m,0)                                 [type = SWAP]

BODY
        /* Nothing to do */
END


/**************************************************
 *                    GETRF_MAX
 * Apply the scale and the update of the step h-1
 * Look for the local max of the step h
 **************************************************/
GETRF_MAX(k,m,h)

// Execution space
k = 0..((descA.mt<descA.nt)?descA.mt-1:descA.nt-1)
m = k..descA.mt-1
h = 0..inline_c %{ 
  int tempkm = ((k)==(descA.mt-1)) ? (descA.m-(k*descA.mb)) : (descA.mb);
  int tempkn = ((k)==(descA.nt-1)) ? (descA.n-(k*descA.nb)) : (descA.nb);
  return ((tempkm<tempkn)? tempkm : tempkn)-1; %}

dmax = inline_c %{
  int nb_init = (descA.mt-k < P) ? descA.mt-k : P;
  int i;
  for(i = 0; nb_init != 1 ; i++)
      nb_init/=2;
  return i; %}

mmax = inline_c %{return ((descA.mt-k < P) ? descA.mt-k : P); %}

hmax = inline_c %{ 
  int tempkm = ((k)==(descA.mt-1)) ? (descA.m-(k*descA.mb)) : (descA.mb);
  int tempkn = ((k)==(descA.nt-1)) ? (descA.n-(k*descA.nb)) : (descA.nb);
  return ((tempkm<tempkn)? tempkm : tempkn)-1; %}

// Parallel partitioning
:A(m, k)

 //RW  T <- (k == 0) ? A(m, k) : C GEMM(k-1, m, k)
 //      -> T TRSM_U(k, k+1..descA.nt-1)
RW  T <- ((k == 0) && (h == 0))? A(m, k)
      <- ((k != 0) && (h == 0))? C GEMM(k-1, m, k)
      <- ((h != 0))? T GETRF_MAX(k,m,h-1)
      -> (h != hmax)? T GETRF_MAX(k,m,h+1)
      -> (h == hmax)? T GETRF_FNL(k,m)
RW  V <- ((h == 0) && (m-k<P))? V V_in(k,m-k)                     [type = SWAP]
      <- ((h != 0) && (m-k<P))? W GETRF_SND(k,dmax,(m-k)%mmax,h-1)   [type = SWAP]
      <- (m-k >= P)? V GETRF_MAX(k,m-P,h)                         [type = SWAP]
      -> ((descA.mt-m)>P)? V GETRF_MAX(k,m+P,h)                   [type = SWAP]
      -> ((descA.mt-m) <= P)? V GETRF_SND(k,0,((m-k)%mmax),h)        [type = SWAP]
      -> ((descA.mt-m) <= P)? W GETRF_SND(k,0,((m-k+1)%mmax),h)      [type = SWAP]

BODY
    DRYRUN(
       int tempmm = ((m)==(descA.mt-1)) ? (descA.m-(m*descA.mb)) : (descA.mb);
       int tempkn = ((k)==(descA.nt-1)) ? (descA.n-(k*descA.nb)) : (descA.nb);
       int ldam = BLKLDD( descA, m );
       int i;
       int pivoting = 0;
       int p = (m == k)? h : 0;
       int index = p;
       double max;

       Dague_Complex64_t *lV = (Dague_Complex64_t*)V;
       Dague_Complex64_t *lT = (Dague_Complex64_t*)T;


       if(h != 0)		
       {
	 /* Applying the previous swap */	 
	 if(m == k) {
	     cblas_zcopy(tempkn, lV + MAXI, 1,
			         lT + h-1,  ldam);
	 }
	 if((m - k) < P)
	     cblas_zcopy(tempkn, lV + INIT, 1,
			         lV + TEMP, 1);

	 int owner_last_index = ((int) (lV[PIVO + h-1]))/descA.mb;
	 int last_index       = ((int) (lV[PIVO + h-1]))%descA.mb;

	 if(owner_last_index == m) {
	   cblas_zcopy(tempkn, lV + TEMP,       1,
		               lT + last_index, ldam);
	 }

	 /* Appliying the update */
	 Dague_Complex64_t alpha = ((Dague_Complex64_t)1.) / (lV[MAXI + h-1]);
	 cblas_zscal(tempmm-p, CBLAS_SADDR( alpha ), lT + ((h-1)*ldam+p), 1 );
	 Dague_Complex64_t mzone = -1.;
	 cblas_zgeru(CblasColMajor, tempmm-p, tempkn-h,
		     CBLAS_SADDR(mzone),
		     lT+ ldam * (h-1) + p,    1,
		     lV+ MAXI         + h, 1,
		     lT+ ldam *  h    + p,    ldam);
       }

       /* Saving the default swap line */
       if(m == k)
       {
	 /* TODO: 2 * memcpy or zcopy */
	   for(i = 0; i < tempkn; i++)
	       lV[INIT + i] = lV[SRCH + i]  = lT[ldam*i+h];
	   lV[PIVO + h] = index+m*descA.mb;
       }else if (m-k < P){
	 cblas_zcopy(tempkn, lT,        ldam,
                             lV + SRCH, 1);
	 lV[PIVO + h] = index+m*descA.mb;
       }
       
       /* Looking for the local max */
       max = cabs(lV[SRCH + h]);
       for(i = p; i < tempmm; i++) { 
	 if(cabs(lT[ldam*h+i]) > max)
	   {
	     index = i;
	     pivoting = 1;
	     max = cabs( lT[ldam*h+i] );
	   }
       }
       if(pivoting) {
	 cblas_zcopy(tempkn,
		     lT + index, ldam,
		     lV + SRCH,  1);
	 lV[PIVO + h] = (Dague_Complex64_t)(index+m*descA.mb);
       }
          );
    printlog();
END


/**************************************************
 *                    GETRF_SND
 * Look and share the global max of the step h 
 * by using the Bruck algorithm
 **************************************************/
GETRF_SND(k,d,m,h)

k = 0..((descA.mt<descA.nt)?descA.mt-1:descA.nt-1)
d = 0.. inline_c %{ 
  int nb_init = (descA.mt-k < P) ? descA.mt-k : P;
  int i;
  for(i = 0; nb_init != 1 ; i++)
      nb_init/=2;
  return i;%}
m = 0..((descA.mt-k < P) ? (descA.mt-k-1) : (P-1))
h = 0..inline_c %{ 
  int tempkm = ((k)==(descA.mt-1)) ? (descA.m-(k*descA.mb)) : (descA.mb);
  int tempkn = ((k)==(descA.nt-1)) ? (descA.n-(k*descA.nb)) : (descA.nb);
  return ((tempkm<tempkn)? tempkm : tempkn)-1; %}

dmax = inline_c %{
  int nb_init = (descA.mt-k < P) ? descA.mt-k : P;
  int i;
  for(i = 0; nb_init != 1 ; i++)
      nb_init/=2;
  return i; %}

mmax = inline_c %{return ((descA.mt-k < P) ? descA.mt-k : P); %}

hmax = inline_c %{ 
  int tempkm = ((k)==(descA.mt-1)) ? (descA.m-(k*descA.mb)) : (descA.mb);
  int tempkn = ((k)==(descA.nt-1)) ? (descA.n-(k*descA.nb)) : (descA.nb);
  return ((tempkm<tempkn)? tempkm : tempkn)-1; %}

pui= inline_c %{ return (int) pow(2,d+1); %}

// Parallel partitioning
:A(k+m, k)

READ  V <- (d == 0)? V GETRF_MAX(k,descA.mt-((descA.mt-(k+m+1))%mmax)-1,h) : W GETRF_SND(k,d-1,m,h)           [type = SWAP]
RW    W <- (d == 0)? V GETRF_MAX(k,descA.mt-((descA.mt-(k+m))%mmax)-1,h) : W GETRF_SND(k,d-1,(mmax+m-pui/2)%mmax,h) [type = SWAP]
	-> (d != dmax)? V GETRF_SND(k,d+1,m,h)	                                                           [type = SWAP]
        -> (d != dmax)? W GETRF_SND(k,d+1,(m+pui)%mmax,h)	                                                   [type = SWAP]
	-> (d == dmax)? V GETRF_MAX(k,k+m,h+1)	                                                           [type = SWAP]
        -> ((h == hmax) && (d == dmax))? V GETRF_FNL(k,(k+m)..(descA.mt-((descA.mt-(k+m+1))%P)-1)..P)      [type = SWAP]

BODY
    DRYRUN(
       int tempkn = ((k)==(descA.nt-1)) ? (descA.n-(k*descA.nb)) : (descA.nb);

       Dague_Complex64_t *lV = (Dague_Complex64_t*)V;
       Dague_Complex64_t *lW = (Dague_Complex64_t*)W;


       if(m  < pui && m < pui/2)
	 cblas_zcopy(tempkn, lV + INIT, 1,
		             lW + INIT, 1);

       if(cabs(lV[SRCH + h]) > cabs(lW[SRCH + h]))
	 {
	   lW[PIVO + h] = lV[PIVO + h];
	   cblas_zcopy(tempkn, lV + SRCH, 1,
		               lW + SRCH, 1);
	 }

       if(d == dmax)
	 cblas_zcopy(tempkn, lW + SRCH, 1,
		             lW + MAXI, 1);

          );
    printlog();
END

/**************************************************
 *                    GETRF_FNL
 * Apply the last scale and update. Then send the
 * pivot to the swap operations.
 **************************************************/
GETRF_FNL(k,m)

// Execution space
k = 0..((descA.mt<descA.nt)?descA.mt-1:descA.nt-1)
m = k..descA.mt-1

dmax = inline_c %{
  int nb_init = (descA.mt-k < P) ? descA.mt-k : P;
  int i;
  for(i = 0; nb_init != 1 ; i++)
      nb_init/=2;
  return i; %}

hmax = inline_c %{ 
  int tempkm = ((k)==(descA.mt-1)) ? (descA.m-(k*descA.mb)) : (descA.mb);
  int tempkn = ((k)==(descA.nt-1)) ? (descA.n-(k*descA.nb)) : (descA.nb);
  return ((tempkm<tempkn)? tempkm : tempkn)-1; %}


// Parallel partitioning
:A(m, k)

RW    T <- T GETRF_MAX(k,m,hmax)
        -> (m == k) ? T TRSM_U(k, k+1..descA.mt-1) : A GEMM(k,m, k+1..descA.mt-1)
        -> A(m, k)
READ  V <- W GETRF_SND(k,dmax,(m-k)%P,hmax)                  [type = SWAP]
RW   IP <- IP IP_in(k,(m-k)%P)                               [type = PIVOT]
        -> (m-k < P)? IP IP_out(k,(m-k))                     [type = PIVOT]
        -> IP SWAP_COLLECT(k, m, k+1..descA.nt-1)            [type = PIVOT]

BODY
 DRYRUN(
   int tempmm = ((m)==(descA.mt-1)) ? (descA.m-(m*descA.mb)) : (descA.mb);
   int tempkn = ((k)==(descA.nt-1)) ? (descA.n-(k*descA.nb)) : (descA.nb);
   int ldam = BLKLDD( descA, m );
   int p = (m == k)? hmax+1 : 0;
   int i;


   Dague_Complex64_t *lV = (Dague_Complex64_t*)V;
   Dague_Complex64_t *lT = (Dague_Complex64_t*)T;


   /* Applying the previous swap */
   if(m == k)
     cblas_zcopy(tempkn, lV + MAXI, 1,
		         lT + hmax, ldam);
	 
   int owner_last_index = ((int) (((Dague_Complex64_t *) V)[PIVO + hmax]))/descA.mb;
   int last_index = ((int) (((Dague_Complex64_t *) V)[PIVO + hmax]))%descA.mb;
   if(owner_last_index == m) {
     cblas_zcopy(tempkn, lV + INIT      , 1,
		         lT + last_index, ldam);
   }

   /* Appliying the update */
   Dague_Complex64_t alpha = ((Dague_Complex64_t) 1.) / (lV[MAXI + hmax]);
   cblas_zscal(tempmm-p, CBLAS_SADDR( alpha ), lT + hmax*ldam + p, 1 );


   for(i = 0; i <= hmax; i++)
     ((int *) IP)[i] = ((int) lV[PIVO + i]) + 1;
	);
    printlog();
END

/**************************************************
 *                    ACOPY_in (pseudo task)
 **************************************************/
ACOPY_in(k,n)

// Execution space
k = 0..((descA.mt<descA.nt)?descA.mt-1:descA.nt-1)
n = k+1..descA.nt-1

// Parallel partitioning
:ACOPY(k%P,n)

// Parameters
READ  A  <- ACOPY(k%P,n)
         -> ACOPY SWAP_COPY(k,n)

BODY
        /* Nothing to do */
END

/**************************************************
 *                    SWAP_COPY
 * Copying the A(k,n) and send it to itself
 **************************************************/
SWAP_COPY(k,n)

// Execution space
k = 0..((descA.mt<descA.nt)?descA.mt-1:descA.nt-1)
n = k+1..descA.nt-1

// Parallel partitioning
:A(k,n)

// Parameters
READ      A <-  (k == 0)? A(k,n) : C GEMM(k-1, k, n)
RW    ACOPY <-  A ACOPY_in(k,n)
            ->  U SWAP_RECV(k,k,n)
CTL     ctl ->  ctl SWAP_PASTE(k,n)

BODY
    DRYRUN(
            /*int tempnn = ((n)==(descA.nt-1)) ? (descA.n-(n*descA.nb)) : (descA.nb);
            int ldak = BLKLDD( descA, k );
            int i;
            int j;
            for(j = 0; j < tempnn; j++)
                  for(i = 0; i < descA.mt; i++)
                        ACOPY[j*ldak+i] = A[j*ldak+i];*/
          );
    printlog("SWAP_COPY(k=%d,n=%d)\n",d,n);
END


/**************************************************
 *                    SWAP_RECV
 * Swapping all the lines from the A(k,n) copy by
 * the current process then sending it to next process
 **************************************************/
SWAP_RECV(k,m,n)

// Execution space
k = 0..((descA.mt<descA.nt)?descA.mt-1:descA.nt-1)
m = k..descA.mt-1
n = k+1..descA.nt-1

// Parallel partitioning
:A(m, n)

// Parameters
/*READ      U <- (m==k)? ACOPY SWAP_COPY(k, n) : ((m-k<P)? U SWAP_RECV(k,m-1,n) : U SWAP_RECV(k,m-P,n))*/
READ      U <- (m==k)? ACOPY SWAP_COPY(k, n)
            <- (m-k<P)? U SWAP_RECV(k,m-1,n) : U SWAP_RECV(k,m-P,n)
            ->  (descA.mt-m>P)? U SWAP_RECV(k,m+P,n)
            ->  (m-k<P-1)? U SWAP_RECV(k,m+1,n)
RW        T <-  T SWAP_COLLECT(k,m,n)
            ->  (m!=k)? C GEMM(k,m,n)
READ     IP <-  IP SWAP_COLLECT(k,m,n)                  [type = PIVOT]

BODY
    DRYRUN(
/* <-  (m==k)? A SWAP_COPY(k, n) : ((m-k>=P)? A SWAP_RECV(k,m-P,n) : A SWAP_RECV(k,descA.mt-((descA.mt-m)%P)-1,n))
   ->  ((descA.mt-m<P) && (k+((m-k)%P) != P-1))? A SWAP_RECV(k,k+((m-k)%P),n)*/
          );
    printlog("SWAP_RECV(k=%d,m=%d,n=%d)\n",k,m,n);
END


/**************************************************
 *                    BUFFER_in (pseudo task)
 **************************************************/
BUFFER_in(k,m,n)

// Execution space
k = 0..((descA.mt<descA.nt)?descA.mt-1:descA.nt-1)
m = 0..((P<descA.mt-k)?P-1:descA.mt-k-1)
n = k+1..descA.nt-1

// Parallel partitioning
:BUFFER((k+m)%P,n)

// Parameters
READ  B  <- BUFFER((k+m)%P,n)
         -> MYBUF SWAP_COLLECT(k,k+m,n)

BODY
        /* Nothing to do */
END

/**************************************************
 *                    SWAP_COLLECT
 * Swapping all the lines for the current process
 * in the temporary buffer
 **************************************************/
SWAP_COLLECT(k,m,n)

// Execution space
k = 0..((descA.mt<descA.nt)?descA.mt-1:descA.nt-1)
m = k..descA.mt-1
n = k+1..descA.nt-1

// Parallel partitioning
:A(m, n)

// Parameters
RW   MYBUF  <-  (m-k>=P)? MYBUF SWAP_COLLECT(k,m-P,n) : B BUFFER_in(k,m-k,n)
            ->  (descA.mt-m>P)? MYBUF SWAP_COLLECT(k,m+P,n)
            ->  ( ((descA.mt-m) <= P) && (((m-k)%P)%2 == 0) )? MYBUF  SWAP_SND(k,0,((m-k)%P)/2,n)
            ->  ( ((descA.mt-m) <= P) && (((m-k)%P)%2 == 1) )? BUFFER  SWAP_SND(k,0,((m-k)%P)/2,n)
            ->  ( ((descA.mt-m) <= P) && (descA.mt-k <  P) && (((descA.mt-k)%2)==1) && (m == descA.mt-1) )? BUFFER SWAP_SND(k,0,((m-k)%P)/2,n)
	    ->  ( ((descA.mt-m) <= P) && (descA.mt-k >= P) && (((P)%2)==1) && (((m+1)%P) == (k%P)) )? BUFFER SWAP_SND(k,0,((m-k)%P)/2,n)
READ      T <-  (k == 0)? A(m,n) : C GEMM(k-1, m, n)
            ->  T SWAP_RECV(k,m,n)
READ     IP <-  IP GETRF_FNL(k,m)                                                                              [type = PIVOT]
            ->  IP SWAP_RECV(k,m,n)                                                                            [type = PIVOT]
            ->  ( ((descA.mt-m) <= P ) && (((m-k)%P)%2 == 0) )? IP    SWAP_SND(k,0,((m-k)%P)/2,n)  	       [type = PIVOT]

BODY
    DRYRUN(
          );
    printlog("SWAP_COLLECT(k=%d,m=%d,n=%d)\n",k,m,n);
END


/**************************************************
 *                    SWAP_SND
 * Sending the temporary buffer to the logarithmic
 * neighbor
 **************************************************/
SWAP_SND(k,d,m,n)

// Execution space
k = 0..((descA.mt<descA.nt)?descA.mt-1:descA.nt-1)
d = 0.. inline_c %{ 
  int nb_init = (descA.mt-k < P) ? descA.mt-k : P;
  int i;
  for(i = 0; nb_init != 1 ; i++)
      nb_init/=2;
  return i;%}
m = 0 .. inline_c %{
  int nb_init = (descA.mt-k < P) ? descA.mt-k : P;
  int i;
  for(i = 0; i <= d ; i++)
      nb_init = (nb_init+1)/2;
  return nb_init-1; %}
n = k+1..descA.nt-1

dmax = inline_c %{
  int nb_init = (descA.mt-k < P) ? descA.mt-k : P;
  int i;
  for(i = 0; nb_init != 1 ; i++)
      nb_init/=2;
  return i; %}
xmax = inline_c %{
       int nb_init = (descA.mt-k < P) ? descA.mt-k : P;
       int i;
       for(i = 0; i < d ; i++)
       	     nb_init = (nb_init+1)/2;
       return nb_init; %}

// Parallel partitioning
pui= inline_c %{ return (int) pow(2,d+1);%}
:A(k+(m*pui), n)
/*:BUFFER(m%Q,n)*/

// Parameters
READ  MYBUF <-  (d == 0)? MYBUF SWAP_COLLECT(k,descA.mt-((descA.mt-k-((m*2)+1))%P)-1,n) : MYBUF SWAP_SND(k,d-1,m*2,n)
            ->  ((m%2==0) && (d != dmax))? MYBUF SWAP_SND(k,d+1,m/2,n)
RW   BUFFER <-  ((d == 0) && (m == (((xmax+1)/2)-1)) && (xmax%2 == 1))? MYBUF SWAP_COLLECT(k,descA.mt-((descA.mt-k-((m*2)+1))%P)-1,n)
	    <-  (d == 0)? MYBUF SWAP_COLLECT(k,descA.mt-((descA.mt-k-((m*2)+2))%P)-1,n)
     	    <-  ((d != 0) && (m == (((xmax+1)/2)-1)) && (xmax%2 == 1))? BUFFER SWAP_SND(k,d-1,m*2,n)
     	    <-  (d != 0)? BUFFER SWAP_SND(k,d-1,m*2+1,n)
            ->  ((d != dmax) && (m%2==1))? BUFFER SWAP_SND(k,d+1,m/2,n)
	    ->  ((d != dmax) && (m == (((xmax+1)/2)-1)) && (((xmax+1)/2)%2 == 1))? BUFFER SWAP_SND(k,d+1,m/2,n)
            ->  (d == dmax)? B SWAP_PASTE(k,n)
READ     IP <-  (d == 0)? IP SWAP_COLLECT(k,descA.mt-((descA.mt-k-((m*2)+1))%P)-1,n) : IP SWAP_SND(k,d-1,m*2,n)           [type = PIVOT]
            ->  ((m%2==0) && (d != dmax))? IP SWAP_SND(k,d+1,m/2,n)                                                             [type = PIVOT]

//descA.mt-((descA.mt-1-k-m)%P)-1
//descA.mt-((descA.mt-2-k-m)%P)-1

BODY
    DRYRUN(
/*        if(m<d)
        {
                ;
        }*/
          );

    printlog("SWAP_SND(k=%d,d=%d,m=%d,n=%d)\n",k,d,m,n);
END

/**************************************************
 *                    SWAP_PASTE
 * Updating the A(k,n)
 **************************************************/
SWAP_PASTE(k,n)

// Execution space
k = 0..((descA.mt<descA.nt)?descA.mt-1:descA.nt-1)
n = k+1..descA.nt-1

d = inline_c %{
  int nb_init = (descA.mt-k < P) ? descA.mt-k : P;
  int i;
  for(i = 0; nb_init != 1 ; i++)
      nb_init/=2;
  return i; %}

// Parallel partitioning
:A(k,n)

// Parameters
CTL     ctl <-  ctl SWAP_COPY(k, n)
            ->  ctl TRSM_U(k,n)
READ      B <-  BUFFER SWAP_SND(k,d,0,n)

BODY
    DRYRUN(
          );
    printlog("SWAP_PASTE(k=%d,n=%d)\n",d,n);
END

/**************************************************
 *                     TRSM_U                     *
 **************************************************/
TRSM_U(k, n)

// Execution space
k = 0..((descA.mt<descA.nt)?descA.mt-1:descA.nt-1)
n = k+1..descA.nt-1

// Parallel partitioning
: A(k, n)

// Parameters
READ    T <- T GETRF_FNL(k,k)
CTL   ctl <- ctl SWAP_PASTE(k,n)
RW      C <- A(k,n)/* B SWAP_PASTE(k,n) */
          -> B GEMM(k, k+1..descA.nt-1, n)
          -> A(k, n)

BODY
        DRYRUN(
            int tempkm = ((k)==(descA.mt-1)) ? (descA.m-(k*descA.mb)) : (descA.mb);
            int tempnn = ((n)==(descA.nt-1)) ? (descA.n-(n*descA.nb)) : (descA.nb);
            int ldak = BLKLDD( descA, k );

            CORE_ztrsm(
                PlasmaLeft, PlasmaLower, PlasmaNoTrans, PlasmaUnit,
                tempkm,
                tempnn,
                (Dague_Complex64_t)1.0, T /*A(k, k)*/, ldak,
                                        C /*A(k, n)*/, ldak )
            );
        printlog("CORE_trsm_U(k=%d,n=%d,ldk=%d,A(%d,%d))\n", tempkm, tempnn,ldak,k,n);

END

/**************************************************
 *                      GEMM                      *
 **************************************************/
GEMM(k, m, n)

// Execution space
k = 0..((descA.mt<descA.nt)?descA.mt-2:descA.nt-2)
m = k+1..descA.mt-1
n = k+1..descA.nt-1

// Parallel partitioning
: A(m, n)

// Parameters
READ  A <- T GETRF_FNL(k, m)
READ  B <- C TRSM_U(k, n)
RW    C <- T SWAP_RECV(k, m, n)
	  -> (n == k+1) ? T GETRF_MAX(k+1,m,0)  /* Panel */
        -> ((m == k+1) && (n >  k+1)) ? A SWAP_COPY(k+1,n)  /* Swap */
        -> ((m >  k)   && (n >  k+1)) ? T SWAP_COLLECT(k+1,m,n)  /* Everything else */

BODY
    DRYRUN(
            int tempmm = ((m)==(descA.mt-1)) ? (descA.m-(m*descA.mb)) : (descA.mb);
            int tempnn = ((n)==(descA.nt-1)) ? (descA.n-(n*descA.nb)) : (descA.nb);
            int ldak = BLKLDD( descA, k );
            int ldam = BLKLDD( descA, m );

           CORE_zgemm(
                      PlasmaNoTrans, PlasmaNoTrans,
                      tempmm, tempnn, descA.mb,
                      (Dague_Complex64_t)-1.0, A /*A(m, k)*/, ldam,
                                               B /*A(k, n)*/, ldak,
                      (Dague_Complex64_t) 1.0, C /*A(m, n)*/, ldam )
          );
     printlog("CORE_gemm(k=%d,m=%d,n=%d,A(%d,%d),ldk=%d,ldm=%d)\n",k,tempmm,tempnn,m,n,ldak,ldam);
END
