extern "C" %{
/*
 *  Copyright (c) 2010
 *
 *  The University of Tennessee and The University
 *  of Tennessee Research Foundation.  All rights
 *  reserved.
 *
 * @precisions normal z -> s d c
 *
 */
#define PRECISION_z

#include <plasma.h>
#include <core_blas.h>

#include "dague.h"
#include "data_distribution.h"
#include "data_dist/matrix/precision.h"
#include "data_dist/matrix/matrix.h"
#include "dplasma/lib/memory_pool.h"
#include "dplasma/lib/dplasmajdf.h"


%}

uplo [type = "PLASMA_enum"]
trans [type = "PLASMA_enum"]
alpha [type = "double"]
descA [type = "tiled_matrix_desc_t"]
A [type = "dague_ddesc_t *"]
beta [type = "double"]
descC [type = "tiled_matrix_desc_t"]
C [type = "dague_ddesc_t *"]


zherk(n,k)
  /* Execution space */
  n = 0..(descC.nt-1)
  k = 0..(descA.nt-1)

  : C(n,n)

  /* A == A(n,k) */
  /* B == C(n,n) */

  READ  A <- A zherk_in_A0(n,k)

  RW    B <- (0==k) ? C(n,n)
          <- (k>=1) ? B zherk(n, k-1)
          -> (descA.nt==(k+1)) ? C(n,n)
          -> (descA.nt>=(k+2)) ? B zherk(n, k+1)

  /*
  Anti-dependencies:

  */

BODY

  int tempnn = ((n)==(descC.nt-1)) ? (descC.n-(n*descC.nb)) : descC.nb;
  int tempkn = ((k)==(descA.nt-1)) ? (descA.n-(k*descA.nb)) : descA.nb;
  int ldan = BLKLDD( descA, n );
  double dbeta = (k == 0 ) ? beta : (double)1.;
  int ldcn = BLKLDD( descC, n );

  DRYRUN(

    CORE_zherk(uplo, trans, tempnn,
        tempkn, alpha, A /* A(n,k) */,
        ldan, dbeta, B /* C(n,n) */,
        ldcn );  );

  printlog("thread %d VP %d CORE_zherk(%d, %d)\n"
           "\t(uplo, trans, tempnn, tempkn, alpha, A(%d,%d)[%p], ldan, dbeta, C(%d,%d)[%p], ldcn)\n",
  context->th_id, context->th_id n, k, n, k, A, n, n, B);

END

/*
 * Pseudo-task
 */
zherk_in_A0(n,k)
  n = 0..(descC.nt-1)
  k = 0..(descA.nt-1)

  : A(n,k)

  RW A <- A(n,k)
       -> A zherk(n,k)
BODY
/* nothing */
END



zgemm(n,m,k1)
  /* Execution space */
  n = 0..inline_c %{ return dague_imin((descC.nt-1),(descC.mt-2)); %}
  m = (n+1)..(descC.mt-1)
  k1 = 0..(descA.nt-1)

  : C(m,n)

  /* C == A(m,k1) */
  /* D == A(n,k1) */
  /* E == C(m,n) */

  READ  C <- C zgemm_in_A0(n,m,k1)

  READ  D <- D zgemm_in_A1(n,m,k1)

  RW    E <- (0==k1) ? C(m,n)
          <- (k1>=1) ? E zgemm(n, m, k1-1)
          -> (descA.nt==(1+k1)) ? C(m,n)
          -> (descA.nt>=(k1+2)) ? E zgemm(n, m, k1+1)

  /*
  Anti-dependencies:

  */

BODY

  int tempmm = ((m)==(descC.mt-1)) ? (descC.m-(m*descC.mb)) : descC.mb;
  int tempnn = ((n)==(descC.nt-1)) ? (descC.n-(n*descC.nb)) : descC.nb;
  int tempkn = ((k1)==(descA.nt-1)) ? (descA.n-(k1*descA.nb)) : descA.nb;
  Dague_Complex64_t zalpha = (Dague_Complex64_t)alpha;
  int ldam = BLKLDD( descA, m );
  int ldan = BLKLDD( descA, n );
  Dague_Complex64_t zbeta = (Dague_Complex64_t)( ( k1 == 0 ) ? beta : 1. );
  int ldcm = BLKLDD( descC, m );

  DRYRUN(

    CORE_zgemm(trans, PlasmaConjTrans, tempmm,
        tempnn, tempkn, zalpha,
        C /* A(m,k1) */, ldam, D /* A(n,k1) */,
        ldan, zbeta, E /* C(m,n) */,
        ldcm );  );

  printlog("thread %d VP %d CORE_zgemm(%d, %d, %d)\n"
           "\t(trans, PlasmaConjTrans, tempmm, tempnn, tempkn, zalpha, A(%d,%d)[%p], ldam, A(%d,%d)[%p], ldan, zbeta, C(%d,%d)[%p], ldcm)\n",
  context->th_id, context->virtual_process->vp_id, n, m, k1, m, k1, C, n, k1, D, m, n, E);

END

/*
 * Pseudo-task
 */
zgemm_in_A0(n,m,k1)
  n = 0..inline_c %{ return dague_imin((descC.mt-2),(descC.nt-1)); %}
  m = (n+1)..(descC.mt-1)
  k1 = 0..(descA.nt-1)

  : A(m,k1)

  RW C <- A(m,k1)
       -> C zgemm(n,m,k1)
BODY
/* nothing */
END


/*
 * Pseudo-task
 */
zgemm_in_A1(n,m,k1)
  n = 0..inline_c %{ return dague_imin((descC.nt-1),(descC.mt-2)); %}
  m = (n+1)..(descC.mt-1)
  k1 = 0..(descA.nt-1)

  : A(n,k1)

  RW D <- A(n,k1)
       -> D zgemm(n,m,k1)
BODY
/* nothing */
END

