extern "C" %{
/*
 * Copyright (c) 2010-2013 The University of Tennessee and The University
 *                         of Tennessee Research Foundation. All rights
 *                         reserved.
 * Copyright (c) 2013      Inria. All rights reserved.
 * $COPYRIGHT
 *
 * @precisions normal z -> s d c
 *
 */
#include "dplasma/lib/dplasmajdf.h"
#include "data_dist/matrix/matrix.h"

#if (PLASMA_VERSION_MAJOR < 2) || ((PLASMA_VERSION_MAJOR == 2) && (PLASMA_VERSION_MINOR < 3))
#define CORE_zssssm(M1, N1, M2, N2, K, IB, A1, LDA1, A2, LDA2, L1, LDL1, L2, LDL2, IPIV) \
        CORE_zssssm(M1,     M2, N2, IB, K, A1, LDA1, A2, LDA2, L1, LDL1, L2, LDL2, IPIV)
#endif

#if (PLASMA_VERSION_MAJOR < 2) || ((PLASMA_VERSION_MAJOR == 2) && (PLASMA_VERSION_MINOR < 4))
#define CORE_zgetrf_incpiv CORE_zgetrf
#endif

%}

dataA     [type = "dague_ddesc_t *"]
dataL     [type = "dague_ddesc_t *" aligned=dataA]
dataIP    [type = "dague_ddesc_t *" aligned=dataA]
INFO      [type = "int*"]

descA     [type = "tiled_matrix_desc_t" hidden = on default = "*((tiled_matrix_desc_t*)dataA)"]
descL     [type = "tiled_matrix_desc_t" hidden = on default = "*((tiled_matrix_desc_t*)dataL)"]
ib        [type = "int" hidden=on default="descL.mb" ]
KT        [type = "int" hidden=on default="dplasma_imin( descA.mt, descA.nt)-1" ]
work_pool [type = "dague_memory_pool_t*" size = "(sizeof(dague_complex64_t) * ib * descA.nb)"]

/************************************************************************************
 *                                    GETRF                                         *
 ************************************************************************************/
zgetrf_out(k) [profile = off]
  k = 0 .. KT

  :dataA(k, k)

  READ A <- A zgetrf(k)
         -> (k < (descA.nt-1)) ? L zgessm(k, (k+1)..(descA.nt-1))   [type = LOWER_TILE]
BODY
{
    /* Nothing */
    printlog("zgetrf_out( %d )\n", k);
}
END

zgetrf(k)
  /* Execution space */
  k = 0 .. KT

  /* Locality */
  :dataA(k, k)

  RW    A  <- ( k == 0 ) ? dataA(k, k) : C zssssm(k-1, k, k)
           -> (k <  (descA.mt-1)) ? U ztstrf(k, k+1)                 [type = UPPER_TILE]
           -> (k == (descA.mt-1)) ? dataA(k, k)
           -> A zgetrf_out(k)

  RW    IP <- dataIP(k, k)                                           [type = PIVOT]
           -> dataIP(k, k)                                           [type = PIVOT]
           -> (k < (descA.nt-1)) ? IP zgessm(k, (k+1)..(descA.nt-1)) [type = PIVOT]

  /* Priority */
  ;(descA.nt-k)*(descA.nt-k)*(descA.nt-k)

BODY
{
    int tempkm = ((k)==(descA.mt-1)) ? (descA.m-(k*descA.mb)) : (descA.mb);
    int tempkn = ((k)==(descA.nt-1)) ? (descA.n-(k*descA.nb)) : (descA.nb);
    int ldak   = BLKLDD(descA, k);
    int iinfo  = 0;

    printlog("CORE_zgetrf(%d)\n"
             "\t(tempkm, tempkn, ib, dataA(%d,%d)[%p], ldak, dataIP(%d,%d)[%p]) => info = %d\n",
             k, k, k, A, k, k, IP, k * descA.mb + iinfo);

#if !defined(DAGUE_DRY_RUN)
    /* Set local IPIV to 0 before generation
     * Better here than a global initialization for locality
     * and it's also done in parallel */
    memset(IP, 0, dplasma_imin(tempkn, tempkm) * sizeof(int) );

    CORE_zgetrf_incpiv(tempkm, tempkn, ib,
                       A  /* dataA(k,k)  */, ldak,
                       IP /* dataIP(k,k) */, &iinfo );

    if ( (iinfo != 0) && (k == descA.mt-1) ) {
        *INFO = k * descA.mb + iinfo; /* Should return if enter here */
        fprintf(stderr, "zgetrf(%d) failed => %d\n", k, *INFO );
    }
#endif /* !defined(DAGUE_DRY_RUN) */
}
END


/************************************************************************************
 *                                    GESSM                                         *
 ************************************************************************************/
zgessm(k, n)
  /* Execution space */
  k = 0   .. KT
  n = k+1 .. descA.nt-1

  /* Locality */
  : dataA(k, n)

  READ  L  <- A zgetrf_out(k)                                        [type = LOWER_TILE]
  READ  IP <- IP zgetrf(k)                                           [type = PIVOT]

  RW    B <- (k == 0) ? dataA(k,n) : C zssssm(k-1, k, n)
          -> (k == (descA.mt-1)) ? dataA(k, n)
          -> (k <  (descA.mt-1)) ? B zssssm(k, k+1, n)

  /* Priority */
  ; (descA.mt-k)*(descA.mt-n)*(descA.mt-n)

BODY
{
    int tempnn = ((n)==(descA.nt-1)) ? (descA.n-(n*descA.nb)) : (descA.nb);
    int tempkm = ((k)==(descA.mt-1)) ? (descA.m-(k*descA.mb)) : (descA.mb);
    int ldak   = BLKLDD( descA, k );

    printlog("CORE_zgessm(%d, %d)\n"
             "\t(tempkm, tempnn, tempkm, ib, dataIP(%d,%d)[%p], \n"
             "\tdataA(%d,%d)[%p], ldak, dataA(%d,%d)[%p], ldak)\n",
             k, n, k, k, IP, k, k, L, k, n, B);

#if !defined(DAGUE_DRY_RUN)
    CORE_zgessm(tempkm, tempnn, tempkm, ib,
                IP /* dataIP(k,k) */,
                L  /* dataA( k,k) */, ldak,
                B  /* dataA( k,n) */, ldak );
#endif /* !defined(DAGUE_DRY_RUN) */
}
END

/************************************************************************************
 *                                    TSTRF                                         *
 ************************************************************************************/
ztstrf_out(k) [profile = off]
  k = 0 .. ( (descA.mt <= descA.nt) ? descA.mt-2 : descA.nt-1 )

  : dataA(k, k)

  READ A <- U ztstrf(k, descA.mt-1)       [type = UPPER_TILE]
         -> dataA(k, k)                   [type = UPPER_TILE]

BODY
{
    /* Nothing */
    printlog("ztstrf_out( %d )\n", k);
}
END

ztstrf(k, m)
  /* Execution space */
  k = 0   .. KT
  m = k+1 .. descA.mt-1

  /* Locality */
  : dataA(m, k)

  RW    U  <- (m == (k+1))        ? A zgetrf(m-1)   : U ztstrf(k, m-1)    [type = UPPER_TILE]
           -> (m == (descA.mt-1)) ? A ztstrf_out(k) : U ztstrf(k, m+1)    [type = UPPER_TILE]

  RW    B  <- (k == 0) ? dataA(m, k) :  C zssssm(k-1, m, k)
           -> (k < (descA.nt-1)) ? A zssssm(k, m, (k+1)..(descA.nt-1))
           -> dataA(m, k)

  RW    L  <- dataL(m, k)                                                 [type = SMALL_L]
           -> dataL(m, k)                                                 [type = SMALL_L]
           -> (k < (descA.nt-1)) ? L  zssssm(k, m, (k+1)..(descA.nt-1))   [type = SMALL_L]

  RW    IP <- dataIP(m, k)                                                [type = PIVOT]
           -> dataIP(m, k)                                                [type = PIVOT]
           -> (k < (descA.nt-1)) ? IP zssssm(k, m, (k+1)..(descA.nt-1))   [type = PIVOT]

  /* Priority */
  ; (descA.mt-k)*(descA.mt-k)*(descA.mt-k)

BODY
{
    int tempmm = ((m)==(descA.mt-1)) ? (descA.m-(m*descA.mb)) : (descA.mb);
    int tempkn = ((k)==(descA.nt-1)) ? (descA.n-(k*descA.nb)) : (descA.nb);
    int ldak   = BLKLDD(descA, k);
    int ldam   = BLKLDD(descA, m);
    int iinfo;
    dague_complex64_t *work = dague_private_memory_pop(work_pool);

    printlog("CORE_ztstrf(%d, %d)\n"
             "\t(tempmm, tempkn, ib, descL.nb, \n"
             "\tdataA(%d,%d)[%p], ldak, dataA(%d,%d)[%p], ldam, \n"
             "\tdataL(%d,%d)[%p], descL.mb, dataIP(%d,%d)[%p], descL.nb)\n",
             k, m, k, k, U, m, k, B, m, k, L, m, k, IP);

#if !defined(DAGUE_DRY_RUN)
    memset(IP, 0, dplasma_imin(tempkn, tempmm) * sizeof(int) );

    CORE_ztstrf(tempmm, tempkn, ib, descL.nb,
                U  /* dataA( k,k) */, ldak,
                B  /* dataA( m,k) */, ldam,
                L  /* dataL( m,k) */, descL.mb,
                IP /* dataIP(m,k) */,
                work, descL.nb, &iinfo );

    if ( (iinfo != 0) && (m == descA.mt-1) ) {
        *INFO = k * descA.mb + iinfo; /* Should return if enter here */
        fprintf(stderr, "ztstrf(%d, %d) failed => %d\n", m, k, *INFO );
    }
#endif /* !defined(DAGUE_DRY_RUN) */

    dague_private_memory_push(work_pool, work);
}
END

/************************************************************************************
 *                                    SSSSM                                         *
 ************************************************************************************/
zssssm_out(k, n) [profile = off]
  k = 0   .. KT-1
  n = k+1 .. descA.nt-1

  : dataA(k, n)

  READ A <- B zssssm(k, descA.mt-1, n)
         -> dataA(k, n)

BODY
{
    /* Nothing */
    printlog("zssssm_out( %d, %d )\n", k, n);
}
END

zssssm(k, m, n)
  /* Execution space */
  k = 0   .. KT
  m = k+1 .. descA.mt-1
  n = k+1 .. descA.nt-1

  /* Locality */
  : dataA(m, n)

  READ  A  <- B ztstrf( k, m)

  RW    B <- (m == (k+1))        ? B zgessm(m-1, n)  : B zssssm(k, m-1, n)
          -> (m == (descA.mt-1)) ? A zssssm_out(k,n) : B zssssm(k, m+1, n)

  RW    C <- (k == 0) ? dataA(m,n) : C zssssm(k-1, m, n)
          -> ((n == (k+1)) & (m == (k+1))) ? A zgetrf(n)         /* Diagonal */
          -> ((n >  (k+1)) & (m == (k+1))) ? B zgessm(k+1, n)    /* Next Row */
          -> ((n == (k+1)) & (m >  (k+1))) ? B ztstrf(n, m)      /* Next Column */
          -> ((n >  (k+1)) & (m >  (k+1))) ? C zssssm(k+1, m, n) /* Trailing submatrix */

  READ  L  <- L ztstrf( k, m )                                   [type = SMALL_L]
  READ  IP <- IP ztstrf(k, m )                                   [type = PIVOT]

  /* Priority */
  ; (descA.mt-k)*(descA.mt-n)*(descA.mt-n)

BODY
{
    int tempmm = (m == (descA.mt-1)) ? (descA.m - m * descA.mb) : descA.mb;
    int tempnn = (n == (descA.nt-1)) ? (descA.n - n * descA.nb) : descA.nb;
    int ldak   = BLKLDD(descA, k);
    int ldam   = BLKLDD(descA, m);

    printlog("CORE_zssssm(%d, %d, %d)\n"
             "\t(%d, %d, %d, %d, %d, %d, dataA(%d,%d)[%p], %d, dataA(%d,%d)[%p], %d, \n"
             "\t dataL(%d,%d)[%p], %d, dataA(%d,%d)[%p], %d, dataIP(%d,%d)[%p])\n",
             k, m, n, descA.nb, tempnn, tempmm, tempnn, descA.nb, ib,
             k, n, B, ldak, m, n, C, ldam, m, k, L, descL.mb, m, k, A, ldam, m, k, IP );

#if !defined(DAGUE_DRY_RUN)
    CORE_zssssm(descA.nb, tempnn, tempmm, tempnn, descA.nb, ib,
                B  /* dataA(k,n) */, ldak,
                C  /* dataA(m,n) */, ldam,
                L  /* dataL(m,k) */, descL.mb,
                A  /* dataA(m,k) */, ldam,
                IP /* dataIP(m,k) */ );
#endif /* !defined(DAGUE_DRY_RUN) */
}
END
