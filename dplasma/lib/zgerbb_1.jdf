extern "C" %{
/*
 *  Copyright (c) 2010      
 * 
 *  The University of Tennessee and The University
 *  of Tennessee Research Foundation.  All rights
 *  reserved.
 *
 * @precisions normal z -> s d c
 *
 */
#define PRECISION_z

#include "dague.h"
#include <plasma.h>
#include <core_blas.h>

#include "data_distribution.h"
#include "data_dist/matrix/precision.h"
#include "data_dist/matrix/matrix.h"
#include "dplasma/lib/memory_pool.h"
#include "dplasma/lib/dplasmajdf.h"

#define BLKLDD(_desc, _k) (_desc)->mb
%}

desc_A [type = "tiled_matrix_desc_t *"]
A      [type = "dague_ddesc_t *"]
desc_T [type = "tiled_matrix_desc_t *"]
T      [type = "dague_ddesc_t *"
        aligned = A]
DPLASMA_IB
pool_1 [type = "dague_memory_pool_t *" size = "((sizeof(PLASMA_Complex64_t))*DPLASMA_IB)*(desc_T.nb)"]
pool_0 [type = "dague_memory_pool_t *" size = "(sizeof(PLASMA_Complex64_t))*(desc_T.nb)"]

minnt1mt2 [type = int
           hidden = on
           default = "dague_imin(desc_A->nt-1, desc_A->mt-2)"]
minnt2mt2 [type = int
           hidden = on
           default = "dague_imin(desc_A->nt-2, desc_A->mt-2)"]
minnt3mt2 [type = int
           hidden = on
           default = "dague_imin(desc_A->nt-3, desc_A->mt-2)"]
NT        [type = int
           hidden = on
           default = "desc_A->nt"]
MT        [type = int
           hidden = on
           default = "desc_A->mt"]

zgeqrt(k)
  /* Execution space */
  k = 0..(NT-1)

  : A(k,k)

  /* A == A(k,k) */
  /* B == T(k,k) */
  /* C == A(k,k) */
  /* D == T(k,k) */
  /* F == A(k,k) */
  /* R == A(m1,k+1) */
  /* V == A(m2,k+1) */

  RW    A <- (NT>=(k+2)) & (MT>=(k+1)) & (k>=1) ? V ztsmlq(k-1, NT-1, k) 
          <- (1>=MT) & (1>=k) ? A(k,k)
          <- (!((1>=MT) & (1>=k))) & (0==k) & (MT>=2) ? A(k,k)
          <- (!((1>=MT) & (1>=k))) & (!((0==k) & (MT>=2))) & (k>=2) & (k>=MT) ? A(k,k)
          <- ((1+k)==NT) & (MT>=(k+1)) & (k>=1) ? R zunmlq(k-1, k) 
          -> (MT>=(k+2)) ? F ztsqrt(k, k+1) 
          -> (NT>=(k+2)) ? C zunmqr(k, (k+1)..(NT-1)) 
          -> ((k+1)>=MT) ? A(k,k)
  RW    B <- B zgeqrt_in_T0(k)
          -> (NT>=(k+2)) ? D zunmqr(k, (k+1)..(NT-1)) 
          -> B zgeqrt_out_T1(k)


  /*
  The following is a superset of the necessary anti-dependencies:
  */

BODY

  int tempkm = ((k)==((desc_A->mt)-1)) ? ((desc_A->m)-(k*(desc_A->mb))) : (desc_A->mb);
  int tempkn = ((k)==((desc_A->nt)-1)) ? ((desc_A->n)-(k*(desc_A->nb))) : (desc_A->nb);
  int ib = DPLASMA_IB;
  int ldak = BLKLDD( desc_A, k );

  void *p_elem_A = dague_private_memory_pop( pool_0 );
  void *p_elem_B = dague_private_memory_pop( pool_1 );

#line 14 "pzgerbb_1_if_cpp.c"
  CORE_zgeqrt(tempkm, tempkn, ib, 
	A /* A(k,k) */, ldak, B /* T(k,k) */, 
	desc_T->mb, p_elem_A, p_elem_B );

  dague_private_memory_push( pool_0, p_elem_A );
  dague_private_memory_push( pool_1, p_elem_B );

  printlog("thread %d CORE_zgeqrt(%d)\n\t(tempkm, tempkn, ib, A(%d,%d)[%p], ldak, T(%d,%d)[%p], desc_T->mb, p_elem_A, p_elem_B)\n",
  context->eu_id, k, k, k, A, k, k, B);

END

/*
 * Pseudo-task
 */
zgeqrt_in_T0(k)
  k = 0..(NT-1)

  : T(k,k)

  RW B <- T(k,k)
       -> B zgeqrt(k)
BODY
/* nothing */
END


/*
 * Pseudo-task
 */
zgeqrt_out_T1(k)
  k = 0..(NT-1)

  : T(k,k)

  RW B <- B zgeqrt(k)
        -> T(k,k)
BODY
/* nothing */
END



zunmqr(k,n)
  /* Execution space */
  k = 0..(NT-2)
  n = (k+1)..(NT-1)

  : A(k,n)

  /* A == A(k,k) */
  /* B == T(k,k) */
  /* C == A(k,k) */
  /* D == T(k,k) */
  /* E == A(k,n) */
  /* J == A(k,n1) */
  /* N == A(k,k+1) */
  /* T == A(k,n2) */
  /* W == A(m2,n2) */

  READ  C <- A zgeqrt(k) 
  READ  D <- B zgeqrt(k) 
  RW    E <- (0==k) ? A(k,n)
          <- (!((0==k))) & (k>=1) & (k>=MT) ? A(k,n)
          <- (k>=1) & (MT>=(1+k)) ? W ztsmlq(k-1, n, k) 
          -> (MT>=(k+2)) ? J ztsmqr(k, k+1, n) 
          -> (n==(k+1)) & (n>=MT) ? N zgelqt(n-1) 
          -> (n>=(2+k)) & ((k+1)>=MT) ? T ztslqt(k, n) 

  /*
  The following is a superset of the necessary anti-dependencies:

  */

BODY

  int tempkm = ((k)==((desc_A->mt)-1)) ? ((desc_A->m)-(k*(desc_A->mb))) : (desc_A->mb);
  int tempnn = ((n)==((desc_A->nt)-1)) ? ((desc_A->n)-(n*(desc_A->nb))) : (desc_A->nb);
  int ib = DPLASMA_IB;
  int ldak = BLKLDD( desc_A, k );

  void *p_elem_A = dague_private_memory_pop( pool_1 );

#line 18 "pzgerbb_1_if_cpp.c"
  CORE_zunmqr(PlasmaLeft, PlasmaConjTrans, tempkm, 
	tempnn, tempkm, ib, 
	C /* A(k,k) */, ldak, D /* T(k,k) */, 
	desc_T->mb, E /* A(k,n) */, ldak, 
	p_elem_A, desc_T->nb );

  dague_private_memory_push( pool_1, p_elem_A );

  printlog("thread %d CORE_zunmqr(%d, %d)\n\t(PlasmaLeft, PlasmaConjTrans, tempkm, tempnn, tempkm, ib, A(%d,%d)[%p], ldak, T(%d,%d)[%p], desc_T->mb, A(%d,%d)[%p], ldak, p_elem_A, desc_T->nb)\n",
  context->eu_id, k, n, k, k, C, k, k, D, k, n, E);

END


ztsqrt(k,m)
  /* Execution space */
  k = 0.. minnt1mt2
  m = (k+1)..(MT-1)

  : A(m,k)

  /* A == A(k,k) */
  /* F == A(k,k) */
  /* G == A(m,k) */
  /* H == T(m,k) */
  /* L == A(m,k) */
  /* M == T(m,k) */
  /* R == A(m1,k+1) */
  /* V == A(m2,k+1) */

  RW    F <- ((k+1)==m) & (NT>=(k+1)) ? A zgeqrt(m-1) 
          <- (m>=(k+2)) ? F ztsqrt(k, m-1) 
          -> (MT>=(m+2)) ? F ztsqrt(k, m+1) 
          -> (MT==(m+1)) ? F ztsqrt_out_A0(k)

  RW    G <- (NT==(k+1)) & (NT>=2) ? R zunmlq(NT-2, m) 
          <- (0==k) ? A(m,k)
          <- (NT>=(2+k)) & (k>=1) ? V ztsmlq(k-1, NT-1, m) 
          -> A(m,k)
          -> (NT>=(k+2)) ? L ztsmqr(k, m, (k+1)..(NT-1)) 
  RW    H <- H ztsqrt_in_T1(k,m)
          -> (NT>=(k+2)) ? M ztsmqr(k, m, (k+1)..(NT-1)) 
          -> H ztsqrt_out_T2(k,m)


  /*
  The following is a superset of the necessary anti-dependencies:

  */

BODY

  int tempmm = ((m)==((desc_A->mt)-1)) ? ((desc_A->m)-(m*(desc_A->mb))) : (desc_A->mb);
  int tempkn = ((k)==((desc_A->nt)-1)) ? ((desc_A->n)-(k*(desc_A->nb))) : (desc_A->nb);
  int ib = DPLASMA_IB;
  int ldak = BLKLDD( desc_A, k );
  int ldam = BLKLDD( desc_A, m );

  void *p_elem_A = dague_private_memory_pop( pool_0 );
  void *p_elem_B = dague_private_memory_pop( pool_1 );

#line 23 "pzgerbb_1_if_cpp.c"
  CORE_ztsqrt(tempmm, tempkn, ib, 
	F /* A(k,k) */, ldak, G /* A(m,k) */, 
	ldam, H /* T(m,k) */, desc_T->mb, 
	p_elem_A, p_elem_B );

  dague_private_memory_push( pool_0, p_elem_A );
  dague_private_memory_push( pool_1, p_elem_B );

  printlog("thread %d CORE_ztsqrt(%d, %d)\n\t(tempmm, tempkn, ib, A(%d,%d)[%p], ldak, A(%d,%d)[%p], ldam, T(%d,%d)[%p], desc_T->mb, p_elem_A, p_elem_B)\n",
  context->eu_id, k, m, k, k, F, m, k, G, m, k, H);

END

/*
 * Pseudo-task
 */
ztsqrt_out_A0(k)
  k = 0..(NT-1)

  : A(k,k)

  RW F <- F ztsqrt(k,MT-1)
        -> A(k,k)
BODY
/* nothing */
END


/*
 * Pseudo-task
 */
ztsqrt_in_T1(k,m)
  k = 0.. minnt1mt2
  m = (k+1)..(MT-1)

  : T(m,k)

  RW H <- T(m,k)
       -> H ztsqrt(k,m)
BODY
/* nothing */
END


/*
 * Pseudo-task
 */
ztsqrt_out_T2(k,m)
  k = 0.. minnt1mt2
  m = (k+1)..(MT-1)

  : T(m,k)

  RW H <- H ztsqrt(k,m)
        -> T(m,k)
BODY
/* nothing */
END



ztsmqr(k,m,n1)
  /* Execution space */
  k = 0.. minnt2mt2
  m = (k+1)..(MT-1)
  n1 = (k+1)..(NT-1)

  : A(m,n1)

  /* E == A(k,n) */
  /* G == A(m,k) */
  /* H == T(m,k) */
  /* J == A(k,n1) */
  /* K == A(m,n1) */
  /* L == A(m,k) */
  /* M == T(m,k) */
  /* N == A(k,k+1) */
  /* R == A(m1,k+1) */
  /* T == A(k,n2) */
  /* W == A(m2,n2) */

  RW    J <- (m==(k+1)) ? E zunmqr(m-1, n1) 
          <- (m>=(2+k)) ? J ztsmqr(k, m-1, n1) 
          -> (MT>=(2+m)) ? J ztsmqr(k, m+1, n1) 
          -> ((1+m)==MT) & ((1+k)==n1) & (m>=(k+1)) ? N zgelqt(n1-1) 
          -> (MT==(1+m)) & (n1>=(k+2)) ? T ztslqt(k, n1) 
  RW    K <- (0==k) ? A(m,n1)
          <- (k>=1) ? W ztsmlq(k-1, n1, m) 
          -> (n1>=(k+2)) ? W ztsmlq(k, n1, m) 
          -> ((1+k)==n1) & (m>=(k+1)) ? R zunmlq(n1-1, m) 
  READ  L <- G ztsqrt(k, m) 
  READ  M <- H ztsqrt(k, m) 

  /*
  The following is a superset of the necessary anti-dependencies:

  */

BODY

  int tempnn = ((n1)==((desc_A->nt)-1)) ? ((desc_A->n)-(n1*(desc_A->nb))) : (desc_A->nb);
  int tempmm = ((m)==((desc_A->mt)-1)) ? ((desc_A->m)-(m*(desc_A->mb))) : (desc_A->mb);
  int ib = DPLASMA_IB;
  int ldak = BLKLDD( desc_A, k );
  int ldam = BLKLDD( desc_A, m );
  int ldwork = ((PlasmaLeft)==(PlasmaLeft)) ? (ib) : (desc_T->nb);

  void *p_elem_A = dague_private_memory_pop( pool_1 );

#line 27 "pzgerbb_1_if_cpp.c"
  CORE_ztsmqr(PlasmaLeft, PlasmaConjTrans, desc_A->mb, 
	tempnn, tempmm, tempnn, 
	desc_A->nb, ib, J /* A(k,n1) */, 
	ldak, K /* A(m,n1) */, ldam, 
	L /* A(m,k) */, ldam, M /* T(m,k) */, 
	desc_T->mb, p_elem_A, ldwork );

  dague_private_memory_push( pool_1, p_elem_A );

  printlog("thread %d CORE_ztsmqr(%d, %d, %d)\n\t(PlasmaLeft, PlasmaConjTrans, desc_A->mb, tempnn, tempmm, tempnn, desc_A->nb, ib, A(%d,%d)[%p], ldak, A(%d,%d)[%p], ldam, A(%d,%d)[%p], ldam, T(%d,%d)[%p], desc_T->mb, p_elem_A, ldwork)\n",
  context->eu_id, k, m, n1, k, n1, J, m, n1, K, m, k, L, m, k, M);

END


zgelqt(k)
  /* Execution space */
  k = 0..(NT-1)

  : A(k,k+1)

  /* E == A(k,n) */
  /* J == A(k,n1) */
  /* N == A(k,k+1) */
  /* O == T(k,k+1) */
  /* P == A(k,k+1) */
  /* Q == T(k,k+1) */
  /* S == A(k,k+1) */

  RW    N <- (NT>=(2+k)) & ((k+1)>=MT) ? E zunmqr(k+1-1, k+1) 
          <- (NT>=(k+2)) & (MT>=(k+2)) ? J ztsmqr(k+1-1, MT-1, k+1) 
          -> (NT>=(k+3)) ? S ztslqt(k, k+2) 
          -> (NT==(2+k)) ? A(k,k+1)
          -> (NT>=(k+2)) & (MT>=(k+2)) ? P zunmlq(k, (k+1)..(MT-1)) 
  RW    O <- O zgelqt_in_T0(k)
          -> (NT>=(k+2)) ? O zgelqt_out_T1(k)

          -> (NT>=(k+2)) & (MT>=(k+2)) ? Q zunmlq(k, (k+1)..(MT-1)) 

  /*
  The following is a superset of the necessary anti-dependencies:
  */

BODY

  int tempkm = ((k)==((desc_A->mt)-1)) ? ((desc_A->m)-(k*(desc_A->mb))) : (desc_A->mb);
  int tempkn = ((k+1)==((desc_A->nt)-1)) ? ((desc_A->n)-((k+1)*(desc_A->nb))) : (desc_A->nb);
  int ib = DPLASMA_IB;
  int ldak = BLKLDD( desc_A, k );

  void *p_elem_A = dague_private_memory_pop( pool_0 );
  void *p_elem_B = dague_private_memory_pop( pool_1 );

#line 32 "pzgerbb_1_if_cpp.c"
  CORE_zgelqt(tempkm, tempkn, ib, 
	N /* A(k,k+1) */, ldak, O /* T(k,k+1) */, 
	desc_T->mb, p_elem_A, p_elem_B );

  dague_private_memory_push( pool_0, p_elem_A );
  dague_private_memory_push( pool_1, p_elem_B );

  printlog("thread %d CORE_zgelqt(%d)\n\t(tempkm, tempkn, ib, A(%d,%d)[%p], ldak, T(%d,%d)[%p], desc_T->mb, p_elem_A, p_elem_B)\n",
  context->eu_id, k, k, k+1, N, k, k+1, O);

END

/*
 * Pseudo-task
 */
zgelqt_in_T0(k)
  k = 0..(NT-1)

  : T(k,k+1)

  RW O <- T(k,k+1)
       -> O zgelqt(k)
BODY
/* nothing */
END


/*
 * Pseudo-task
 */
zgelqt_out_T1(k)
  k = 0..(NT-2)

  : T(k,k+1)

  RW O <- O zgelqt(k)
        -> T(k,k+1)
BODY
/* nothing */
END



zunmlq(k,m1)
  /* Execution space */
  k = 0.. minnt1mt2
  m1 = (k+1)..(MT-1)

  : A(m1,k+1)

  /* A == A(k,k) */
  /* G == A(m,k) */
  /* K == A(m,n1) */
  /* N == A(k,k+1) */
  /* O == T(k,k+1) */
  /* P == A(k,k+1) */
  /* Q == T(k,k+1) */
  /* R == A(m1,k+1) */
  /* V == A(m2,k+1) */

  READ  P <- (NT>=(k+2)) ? N zgelqt(k) 
  READ  Q <- (NT>=(2+k)) ? O zgelqt(k) 
  RW    R <- (NT>=(k+2)) ? K ztsmqr(k+1-1, m1, k+1) 
          -> (NT==(m1+1)) & (NT==(k+2)) ? A zgeqrt(m1) 
          -> (NT>=(3+k)) ? V ztsmlq(k, k+2, m1) 
          -> (NT==(k+2)) & (m1>=NT) ? G ztsqrt(k+1, m1) 

  /*
  The following is a superset of the necessary anti-dependencies:
  */

BODY

  int tempmm = ((m1)==((desc_A->mt)-1)) ? ((desc_A->m)-(m1*(desc_A->mb))) : (desc_A->mb);
  int tempkn = ((k+1)==((desc_A->nt)-1)) ? ((desc_A->n)-((k+1)*(desc_A->nb))) : (desc_A->nb);
  int ib = DPLASMA_IB;
  int ldak = BLKLDD( desc_A, k );
  int ldam = BLKLDD( desc_A, m1 );

  void *p_elem_A = dague_private_memory_pop( pool_1 );

#line 37 "pzgerbb_1_if_cpp.c"
  CORE_zunmlq(PlasmaRight, PlasmaConjTrans, tempmm, 
	tempkn, tempkn, ib, 
	P /* A(k,k+1) */, ldak, Q /* T(k,k+1) */, 
	desc_T->mb, R /* A(m1,k+1) */, ldam, 
	p_elem_A, desc_T->nb );

  dague_private_memory_push( pool_1, p_elem_A );

  printlog("thread %d CORE_zunmlq(%d, %d)\n\t(PlasmaRight, PlasmaConjTrans, tempmm, tempkn, tempkn, ib, A(%d,%d)[%p], ldak, T(%d,%d)[%p], desc_T->mb, A(%d,%d)[%p], ldam, p_elem_A, desc_T->nb)\n",
  context->eu_id, k, m1, k, k+1, P, k, k+1, Q, m1, k+1, R);

END


ztslqt(k,n2)
  /* Execution space */
  k = 0..(NT-3)
  n2 = (k+2)..(NT-1)

  : A(k,n2)

  /* E == A(k,n) */
  /* J == A(k,n1) */
  /* N == A(k,k+1) */
  /* S == A(k,k+1) */
  /* T == A(k,n2) */
  /* U == T(k,n2) */
  /* X == A(k,n2) */
  /* Y == T(k,n2) */

  RW    S <- ((2+k)==n2) ? N zgelqt(n2-2) 
          <- (n2>=(3+k)) ? S ztslqt(k, n2-1) 
          -> (NT==(n2+1)) ? S ztslqt_out_A0(k)

          -> (NT>=(n2+2)) ? S ztslqt(k, n2+1) 
  RW    T <- ((1+k)>=MT) ? E zunmqr(k, n2) 
          <- (MT>=(k+2)) ? J ztsmqr(k, MT-1, n2) 
          -> (MT>=(k+2)) ? X ztsmlq(k, n2, (k+1)..(MT-1)) 
          -> A(k,n2)
  RW    U <- U ztslqt_in_T1(k,n2)
          -> U ztslqt_out_T2(k,n2)

          -> (MT>=(k+2)) ? Y ztsmlq(k, n2, (k+1)..(MT-1)) 

  /*
  The following is a superset of the necessary anti-dependencies:

  */

BODY

  int tempkm = ((k)==((desc_A->mt)-1)) ? ((desc_A->m)-(k*(desc_A->mb))) : (desc_A->mb);
  int tempnn = ((n2)==((desc_A->nt)-1)) ? ((desc_A->n)-(n2*(desc_A->nb))) : (desc_A->nb);
  int ib = DPLASMA_IB;
  int ldak = BLKLDD( desc_A, k );

  void *p_elem_A = dague_private_memory_pop( pool_0 );
  void *p_elem_B = dague_private_memory_pop( pool_1 );

#line 41 "pzgerbb_1_if_cpp.c"
  CORE_ztslqt(tempkm, tempnn, ib, 
	S /* A(k,k+1) */, ldak, T /* A(k,n2) */, 
	ldak, U /* T(k,n2) */, desc_T->mb, 
	p_elem_A, p_elem_B );

  dague_private_memory_push( pool_0, p_elem_A );
  dague_private_memory_push( pool_1, p_elem_B );

  printlog("thread %d CORE_ztslqt(%d, %d)\n\t(tempkm, tempnn, ib, A(%d,%d)[%p], ldak, A(%d,%d)[%p], ldak, T(%d,%d)[%p], desc_T->mb, p_elem_A, p_elem_B)\n",
  context->eu_id, k, n2, k, k+1, S, k, n2, T, k, n2, U);

END

/*
 * Pseudo-task
 */
ztslqt_out_A0(k)
 k = 0..(NT-3)

  : A(k,k+1)

  RW S <- S ztslqt(k,NT-1)
        -> A(k,k+1)
BODY
/* nothing */
END


/*
 * Pseudo-task
 */
ztslqt_in_T1(k,n2)
  k = 0..(NT-3)
  n2 = (k+2)..(NT-1)

  : T(k,n2)

  RW U <- T(k,n2)
       -> U ztslqt(k,n2)
BODY
/* nothing */
END


/*
 * Pseudo-task
 */
ztslqt_out_T2(k,n2)
  k = 0..(NT-3)
  n2 = (k+2)..(NT-1)

  : T(k,n2)

  RW U <- U ztslqt(k,n2)
        -> T(k,n2)
BODY
/* nothing */
END



ztsmlq(k,n2,m2)
  /* Execution space */
  k = 0.. minnt3mt2
  n2 = (k+2)..(NT-1)
  m2 = (k+1)..(MT-1)

  : A(m2,n2)

  /* A == A(k,k) */
  /* E == A(k,n) */
  /* G == A(m,k) */
  /* K == A(m,n1) */
  /* R == A(m1,k+1) */
  /* T == A(k,n2) */
  /* U == T(k,n2) */
  /* V == A(m2,k+1) */
  /* W == A(m2,n2) */
  /* X == A(k,n2) */
  /* Y == T(k,n2) */

  RW    V <- (n2>=(3+k)) ? V ztsmlq(k, n2-1, m2) 
          <- ((2+k)==n2) & (m2>=(1+k)) ? R zunmlq(n2-2, m2) 
          -> (NT>=(n2+2)) ? V ztsmlq(k, n2+1, m2) 
          -> (NT==(n2+1)) & (m2>=(k+2)) ? G ztsqrt(k+1, m2) 
          -> ((1+n2)==NT) & ((k+1)==m2) & (n2>=(k+2)) ? A zgeqrt(m2) 
  RW    W <- K ztsmqr(k, m2, n2) 
          -> (m2>=(2+k)) ? K ztsmqr(k+1, m2, n2) 
          -> ((k+1)==m2) & (n2>=(k+2)) & (NT>=(k+2)) ? E zunmqr(m2, n2) 
  READ  X <- T ztslqt(k, n2) 
  READ  Y <- U ztslqt(k, n2) 

  /*
  The following is a superset of the necessary anti-dependencies:
  */

BODY

  int tempmm = ((m2)==((desc_A->mt)-1)) ? ((desc_A->m)-(m2*(desc_A->mb))) : (desc_A->mb);
  int tempnn = ((n2)==((desc_A->nt)-1)) ? ((desc_A->n)-(n2*(desc_A->nb))) : (desc_A->nb);
  int ib = DPLASMA_IB;
  int ldam = BLKLDD( desc_A, m2 );
  int ldak = BLKLDD( desc_A, k );
  int ldwork = ((PlasmaRight)==(PlasmaLeft)) ? (ib) : (desc_T->nb);

  void *p_elem_A = dague_private_memory_pop( pool_1 );

#line 46 "pzgerbb_1_if_cpp.c"
  CORE_ztsmlq(PlasmaRight, PlasmaConjTrans, tempmm, 
	desc_A->nb, tempmm, tempnn, 
	desc_A->mb, ib, V /* A(m2,k+1) */, 
	ldam, W /* A(m2,n2) */, ldam, 
	X /* A(k,n2) */, ldak, Y /* T(k,n2) */, 
	desc_T->mb, p_elem_A, ldwork );

  dague_private_memory_push( pool_1, p_elem_A );

  printlog("thread %d CORE_ztsmlq(%d, %d, %d)\n\t(PlasmaRight, PlasmaConjTrans, tempmm, desc_A->nb, tempmm, tempnn, desc_A->mb, ib, A(%d,%d)[%p], ldam, A(%d,%d)[%p], ldam, A(%d,%d)[%p], ldak, T(%d,%d)[%p], desc_T->mb, p_elem_A, ldwork)\n",
  context->eu_id, k, n2, m2, m2, k+1, V, m2, n2, W, k, n2, X, k, n2, Y);

END
