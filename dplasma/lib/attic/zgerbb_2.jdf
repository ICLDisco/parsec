extern "C" %{
/*
 *  Copyright (c) 2010-2013      
 * 
 *  The University of Tennessee and The University
 *  of Tennessee Research Foundation.  All rights
 *  reserved.
 *
 * @precisions normal z -> s d c
 *
 */
#define PRECISION_z

#include "dague.h"
#include <core_blas.h>
#include <core_blas.h>

#include "data_distribution.h"
#include "data_dist/matrix/precision.h"
#include "data_dist/matrix/matrix.h"
#include "dplasma/lib/memory_pool.h"
#include "dplasma/lib/dplasmajdf.h"

%}

desc_A [type = "tiled_matrix_desc_t *"]
A      [type = "dague_ddesc_t *"]
desc_T [type = "tiled_matrix_desc_t *"]
T      [type = "dague_ddesc_t *"
        aligned = A]
DPLASMA_IB
pool_1 [type = "dague_memory_pool_t *" size = "((sizeof(PLASMA_Complex64_t))*DPLASMA_IB)*(desc_T->nb)"]
pool_0 [type = "dague_memory_pool_t *" size = "(sizeof(PLASMA_Complex64_t))*(desc_T->nb)"]

minnt1mt2 [type = int
           hidden = on
           default = "dplasma_imin(desc_A->nt-1, desc_A->mt-2)"]
minnt2mt2 [type = int
           hidden = on
           default = "dplasma_imin(desc_A->nt-2, desc_A->mt-2)"]
minnt3mt2 [type = int
           hidden = on
           default = "dplasma_imin(desc_A->nt-3, desc_A->mt-2)"]
NT        [type = int
           hidden = on
           default = "desc_A->nt"]
MT        [type = int
           hidden = on
           default = "desc_A->mt"]

zgelqt(k)
  /* Execution space */
  k = 0..(MT-1)

  : A(k,k)

  /* A == A(k,k) */
  /* B == T(k,k) */
  /* C == A(k,k) */
  /* D == T(k,k) */
  /* F == A(k,k) */
  /* R == A(k+1,n1) */
  /* V == A(k+1,n2) */

  RW    A <- (MT>=(k+2)) & (NT>=(k+1)) & (k>=1) ? V ztsmqr(k-1, MT-1, k) 
          <- (1>=NT) & (1>=k) ? A(k,k)
          <- (!((1>=NT) & (1>=k))) & (0==k) & (NT>=2) ? A(k,k)
          <- (!((1>=NT) & (1>=k))) & (!((0==k) & (NT>=2))) & (k>=2) & (k>=NT) ? A(k,k)
          <- ((1+k)==MT) & (NT>=(k+1)) & (k>=1) ? R zunmqr(k-1, k) 
          -> (MT>=(2+k)) ? C zunmlq(k, (k+1)..(MT-1)) 
          -> (NT>=(k+2)) ? F ztslqt(k, k+1) 
          -> ((k+1)>=NT) ? A(k,k)
  RW    B <- B zgelqt_in_data_T0(k)
          -> (MT>=(2+k)) ? D zunmlq(k, (k+1)..(MT-1)) 
          -> B zgelqt_out_data_T1(k)


  /*
  The following is a superset of the necessary anti-dependencies:

  */

BODY
  int tempkm = ((k)==((MT)-1)) ? ((desc_A->m)-(k*(desc_A->mb))) : (desc_A->mb);
  int tempkn = ((k)==((NT)-1)) ? ((desc_A->n)-(k*(desc_A->nb))) : (desc_A->nb);
  int ib = DPLASMA_IB;
  int ldak = BLKLDDP( desc_A, k );

  void *p_elem_A = dague_private_memory_pop( pool_0 );
  void *p_elem_B = dague_private_memory_pop( pool_1 );

  CORE_zgelqt(tempkm, tempkn, ib, 
        A /* A(k,k) */, ldak, B /* T(k,k) */, 
        desc_T->mb, p_elem_A, p_elem_B );

  dague_private_memory_push( pool_0, p_elem_A );
  dague_private_memory_push( pool_1, p_elem_B );

  printlog("CORE_zgelqt(%d)\n\t(tempkm, tempkn, ib, A(%d,%d)[%p], ldak, T(%d,%d)[%p], desc_T->mb, p_elem_A, p_elem_B)\n",
  k, k, k, A, k, k, B);

END

/*
 * Pseudo-task
 */
zgelqt_in_data_T0(k) [profile = off]
  k = 0..(MT-1)

  : T(k,k)

  RW B <- T(k,k)
       -> B zgelqt(k)
BODY
/* nothing */
END


/*
 * Pseudo-task
 */
zgelqt_out_data_T1(k) [profile = off]
  k = 0..(MT-1)

  : T(k,k)

  RW B <- B zgelqt(k)
        -> T(k,k)
BODY
/* nothing */
END



zunmlq(k,m)
  /* Execution space */
  k = 0..(MT-2)
  m = (k+1)..(MT-1)

  : A(m,k)

  /* A == A(k,k) */
  /* B == T(k,k) */
  /* C == A(k,k) */
  /* D == T(k,k) */
  /* E == A(m,k) */
  /* J == A(m1,k) */
  /* N == A(k+1,k) */
  /* T == A(m2,k) */
  /* W == A(m2,n2) */

  READ  C <- A zgelqt(k) 
  READ  D <- B zgelqt(k) 
  RW    E <- (k>=1) & (NT>=(k+1)) ? W ztsmqr(k-1, m, k) 
          <- (0==k) ? A(m,k)
          <- (!((0==k))) & (k>=1) & (k>=NT) ? A(m,k)
          -> (NT>=(k+2)) ? J ztsmlq(k, k+1, m) 
          -> (m>=(2+k)) & ((k+1)>=NT) ? T ztsqrt(k, m) 
          -> ((k+1)==m) & ((k+1)>=NT) ? N zgeqrt(m-1) 

  /*
  The following is a superset of the necessary anti-dependencies:

  */

BODY

  int tempmm = ((m)==((MT)-1)) ? ((desc_A->m)-(m*(desc_A->mb))) : (desc_A->mb);
  int tempkn = ((k)==((NT)-1)) ? ((desc_A->n)-(k*(desc_A->nb))) : (desc_A->nb);
  int ib = DPLASMA_IB;
  int ldak = BLKLDDP( desc_A, k );
  int ldam = BLKLDDP( desc_A, m );

  void *p_elem_A = dague_private_memory_pop( pool_1 );

  CORE_zunmlq(PlasmaRight, PlasmaConjTrans, tempmm, 
        tempkn, tempkn, ib, 
        C /* A(k,k) */, ldak, D /* T(k,k) */, 
        desc_T->mb, E /* A(m,k) */, ldam, 
        p_elem_A, desc_T->nb );

  dague_private_memory_push( pool_1, p_elem_A );

  printlog("CORE_zunmlq(%d, %d)\n\t(PlasmaRight, PlasmaConjTrans, tempmm, tempkn, tempkn, ib, A(%d,%d)[%p], ldak, T(%d,%d)[%p], desc_T->mb, A(%d,%d)[%p], ldam, p_elem_A, desc_T->nb)\n",
  k, m, k, k, C, k, k, D, m, k, E);

END


ztslqt(k,n)
  /* Execution space */
  k = 0.. minnt1mt2
  n = (k+1)..(NT-1)

  : A(k,n)

  /* A == A(k,k) */
  /* F == A(k,k) */
  /* G == A(k,n) */
  /* H == T(k,n) */
  /* L == A(k,n) */
  /* M == T(k,n) */
  /* R == A(k+1,n1) */
  /* V == A(k+1,n2) */

  RW    F <- ((k+1)==n) & (MT>=(1+k)) ? A zgelqt(n-1) 
          <- (n>=(2+k)) ? F ztslqt(k, n-1) 
          -> (NT==(n+1)) ? F ztslqt_out_desc_A0(k)

          -> (NT>=(2+n)) ? F ztslqt(k, n+1) 
  RW    G <- (MT>=(k+2)) & (k>=1) ? V ztsmqr(k-1, MT-1, n) 
          <- ((1+k)==MT) & (n>=(k+1)) & (k>=1) ? R zunmqr(MT-2, n) 
          <- (0==k) ? A(k,n)
          -> (MT>=(k+2)) ? L ztsmlq(k, n, (k+1)..(MT-1)) 
          -> A(k,n)
  RW    H <- H ztslqt_in_data_T1(k,n)
          -> H ztslqt_out_data_T2(k,n)

          -> (MT>=(2+k)) ? M ztsmlq(k, n, (k+1)..(MT-1)) 

  /*
  The following is a superset of the necessary anti-dependencies:

  */

BODY

  int tempkm = ((k)==((MT)-1)) ? ((desc_A->m)-(k*(desc_A->mb))) : (desc_A->mb);
  int tempnn = ((n)==((NT)-1)) ? ((desc_A->n)-(n*(desc_A->nb))) : (desc_A->nb);
  int ib = DPLASMA_IB;
  int ldak = BLKLDDP( desc_A, k );

  void *p_elem_A = dague_private_memory_pop( pool_0 );
  void *p_elem_B = dague_private_memory_pop( pool_1 );

  CORE_ztslqt(tempkm, tempnn, ib, 
        F /* A(k,k) */, ldak, G /* A(k,n) */, 
        ldak, H /* T(k,n) */, desc_T->mb, 
        p_elem_A, p_elem_B );

  dague_private_memory_push( pool_0, p_elem_A );
  dague_private_memory_push( pool_1, p_elem_B );

  printlog("CORE_ztslqt(%d, %d)\n\t(tempkm, tempnn, ib, A(%d,%d)[%p], ldak, A(%d,%d)[%p], ldak, T(%d,%d)[%p], desc_T->mb, p_elem_A, p_elem_B)\n",
  k, n, k, k, F, k, n, G, k, n, H);

END

/*
 * Pseudo-task
 */
ztslqt_out_desc_A0(k) [profile = off]
  k = 0..(MT-1)

  : A(k,k)

  RW F <- F ztslqt(k,NT-1)
        -> A(k,k)
BODY
/* nothing */
END


/*
 * Pseudo-task
 */
ztslqt_in_data_T1(k,n) [profile = off]
  k = 0.. minnt1mt2
  n = (k+1)..(NT-1)

  : T(k,n)

  RW H <- T(k,n)
       -> H ztslqt(k,n)
BODY
/* nothing */
END


/*
 * Pseudo-task
 */
ztslqt_out_data_T2(k,n) [profile = off]
  k = 0.. minnt1mt2
  n = (k+1)..(NT-1)

  : T(k,n)

  RW H <- H ztslqt(k,n)
        -> T(k,n)
BODY
/* nothing */
END



ztsmlq(k,n,m1)
  /* Execution space */
  k = 0.. minnt2mt2
  n = (k+1)..(NT-1)
  m1 = (k+1)..(MT-1)

  : A(m1,n)

  /* E == A(m,k) */
  /* G == A(k,n) */
  /* H == T(k,n) */
  /* J == A(m1,k) */
  /* K == A(m1,n) */
  /* L == A(k,n) */
  /* M == T(k,n) */
  /* N == A(k+1,k) */
  /* R == A(k+1,n1) */
  /* T == A(m2,k) */
  /* W == A(m2,n2) */

  RW    J <- (n==(k+1)) ? E zunmlq(n-1, m1) 
          <- (n>=(2+k)) ? J ztsmlq(k, n-1, m1) 
          -> (NT>=(n+2)) ? J ztsmlq(k, n+1, m1) 
          -> ((1+n)==NT) & ((k+1)==m1) & (n>=(k+1)) ? N zgeqrt(m1-1) 
          -> (NT==(n+1)) & (m1>=(2+k)) ? T ztsqrt(k, m1) 
  RW    K <- (0==k) ? A(m1,n)
          <- (k>=1) ? W ztsmqr(k-1, m1, n) 
          -> (m1>=(k+2)) ? W ztsmqr(k, m1, n) 
          -> ((1+k)==m1) & (n>=(k+1)) ? R zunmqr(m1-1, n) 
  READ  L <- G ztslqt(k, n) 
  READ  M <- H ztslqt(k, n) 

  /*
  The following is a superset of the necessary anti-dependencies:

  */

BODY

  int tempmm = ((m1)==((MT)-1)) ? ((desc_A->m)-(m1*(desc_A->mb))) : (desc_A->mb);
  int tempnn = ((n)==((NT)-1)) ? ((desc_A->n)-(n*(desc_A->nb))) : (desc_A->nb);
  int ib = DPLASMA_IB;
  int ldam = BLKLDDP( desc_A, m1 );
  int ldak = BLKLDDP( desc_A, k );
  int ldwork = ((PlasmaRight)==(PlasmaLeft)) ? (ib) : (desc_T->nb);

  void *p_elem_A = dague_private_memory_pop( pool_1 );

  CORE_ztsmlq(PlasmaRight, PlasmaConjTrans, tempmm, 
        desc_A->nb, tempmm, tempnn, 
        desc_A->mb, ib, J /* A(m1,k) */, 
        ldam, K /* A(m1,n) */, ldam, 
        L /* A(k,n) */, ldak, M /* T(k,n) */, 
        desc_T->mb, p_elem_A, ldwork );

  dague_private_memory_push( pool_1, p_elem_A );

  printlog("CORE_ztsmlq(%d, %d, %d)\n\t(PlasmaRight, PlasmaConjTrans, tempmm, desc_A->nb, tempmm, tempnn, desc_A->mb, ib, A(%d,%d)[%p], ldam, A(%d,%d)[%p], ldam, A(%d,%d)[%p], ldak, T(%d,%d)[%p], desc_T->mb, p_elem_A, ldwork)\n",
  k, n, m1, m1, k, J, m1, n, K, k, n, L, k, n, M);

END


zgeqrt(k)
  /* Execution space */
  k = 0..(MT-1)

  : A(k+1,k)

  /* E == A(m,k) */
  /* J == A(m1,k) */
  /* N == A(k+1,k) */
  /* O == T(k+1,k) */
  /* P == A(k+1,k) */
  /* Q == T(k+1,k) */
  /* S == A(k+1,k) */

  RW    N <- (MT>=(2+k)) & ((k+1)>=NT) ? E zunmlq(k+1-1, k+1) 
          <- (MT>=(k+2)) & (NT>=(k+2)) ? J ztsmlq(k+1-1, NT-1, k+1) 
          -> (MT==(2+k)) ? A(k+1,k)
          -> (MT>=(k+3)) ? S ztsqrt(k, k+2) 
          -> (MT>=(k+2)) & (NT>=(k+2)) ? P zunmqr(k, (k+1)..(NT-1)) 
  RW    O <- O zgeqrt_in_data_T0(k)
          -> (MT>=(k+2)) & (NT>=(k+2)) ? Q zunmqr(k, (k+1)..(NT-1)) 
          -> (MT>=(k+2)) ? O zgeqrt_out_data_T1(k)


  /*
  The following is a superset of the necessary anti-dependencies:

  */

BODY

  int tempkm = ((k+1)==((MT)-1)) ? ((desc_A->m)-((k+1)*(desc_A->mb))) : (desc_A->mb);
  int tempkn = ((k)==((NT)-1)) ? ((desc_A->n)-(k*(desc_A->nb))) : (desc_A->nb);
  int ib = DPLASMA_IB;
  int ldak = BLKLDDP( desc_A, k+1 );

  void *p_elem_A = dague_private_memory_pop( pool_0 );
  void *p_elem_B = dague_private_memory_pop( pool_1 );

  CORE_zgeqrt(tempkm, tempkn, ib, 
        N /* A(k+1,k) */, ldak, O /* T(k+1,k) */, 
        desc_T->mb, p_elem_A, p_elem_B );

  dague_private_memory_push( pool_0, p_elem_A );
  dague_private_memory_push( pool_1, p_elem_B );

  printlog("CORE_zgeqrt(%d)\n\t(tempkm, tempkn, ib, A(%d,%d)[%p], ldak, T(%d,%d)[%p], desc_T->mb, p_elem_A, p_elem_B)\n",
  k, k+1, k, N, k+1, k, O);

END

/*
 * Pseudo-task
 */
zgeqrt_in_data_T0(k) [profile = off]
  k = 0..(MT-1)

  : T(k+1,k)

  RW O <- T(k+1,k)
       -> O zgeqrt(k)
BODY
/* nothing */
END


/*
 * Pseudo-task
 */
zgeqrt_out_data_T1(k) [profile = off]
  k = 0..(MT-2)

  : T(k+1,k)

  RW O <- O zgeqrt(k)
        -> T(k+1,k)
BODY
/* nothing */
END



zunmqr(k,n1)
  /* Execution space */
  k = 0.. minnt1mt2
  n1 = (k+1)..(NT-1)

  : A(k+1,n1)

  /* A == A(k,k) */
  /* G == A(k,n) */
  /* K == A(m1,n) */
  /* N == A(k+1,k) */
  /* O == T(k+1,k) */
  /* P == A(k+1,k) */
  /* Q == T(k+1,k) */
  /* R == A(k+1,n1) */
  /* V == A(k+1,n2) */

  READ  P <- (MT>=(k+2)) ? N zgeqrt(k) 
  READ  Q <- (MT>=(2+k)) ? O zgeqrt(k) 
  RW    R <- (MT>=(k+2)) ? K ztsmlq(k+1-1, n1, k+1) 
          -> (MT>=(3+k)) ? V ztsmqr(k, k+2, n1) 
          -> (MT==(2+k)) & (n1>=MT) ? G ztslqt(k+1, n1) 
          -> (MT==(n1+1)) & (MT==(k+2)) ? A zgelqt(n1) 

  /*
  The following is a superset of the necessary anti-dependencies:

  */

BODY

  int tempkm = ((k+1)==((MT)-1)) ? ((desc_A->m)-((k+1)*(desc_A->mb))) : (desc_A->mb);
  int tempnn = ((n1)==((NT)-1)) ? ((desc_A->n)-(n1*(desc_A->nb))) : (desc_A->nb);
  int ib = DPLASMA_IB;
  int ldak = BLKLDDP( desc_A, k+1 );

  void *p_elem_A = dague_private_memory_pop( pool_1 );

  CORE_zunmqr(PlasmaLeft, PlasmaConjTrans, tempkm, 
        tempnn, tempkm, ib, 
        P /* A(k+1,k) */, ldak, Q /* T(k+1,k) */, 
        desc_T->mb, R /* A(k+1,n1) */, ldak, 
        p_elem_A, desc_T->nb );

  dague_private_memory_push( pool_1, p_elem_A );

  printlog("CORE_zunmqr(%d, %d)\n\t(PlasmaLeft, PlasmaConjTrans, tempkm, tempnn, tempkm, ib, A(%d,%d)[%p], ldak, T(%d,%d)[%p], desc_T->mb, A(%d,%d)[%p], ldak, p_elem_A, desc_T->nb)\n",
  k, n1, k+1, k, P, k+1, k, Q, k+1, n1, R);

END


ztsqrt(k,m2)
  /* Execution space */
  k = 0..(MT-3)
  m2 = (k+2)..(MT-1)

  : A(m2,k)

  /* E == A(m,k) */
  /* J == A(m1,k) */
  /* N == A(k+1,k) */
  /* S == A(k+1,k) */
  /* T == A(m2,k) */
  /* U == T(m2,k) */
  /* X == A(m2,k) */
  /* Y == T(m2,k) */

  RW    S <- ((2+k)==m2) ? N zgeqrt(m2-2) 
          <- (m2>=(3+k)) ? S ztsqrt(k, m2-1) 
          -> (MT==(m2+1)) ? S ztsqrt_out_desc_A0(k)

          -> (MT>=(m2+2)) ? S ztsqrt(k, m2+1) 
  RW    T <- ((1+k)>=NT) ? E zunmlq(k, m2) 
          <- (NT>=(k+2)) ? J ztsmlq(k, NT-1, m2) 
          -> A(m2,k)
          -> (NT>=(k+2)) ? X ztsmqr(k, m2, (k+1)..(NT-1)) 
  RW    U <- U ztsqrt_in_data_T1(k,m2)
          -> U ztsqrt_out_data_T2(k,m2)

          -> (NT>=(k+2)) ? Y ztsmqr(k, m2, (k+1)..(NT-1)) 

  /*
  The following is a superset of the necessary anti-dependencies:

  */

BODY

  int tempmm = ((m2)==((MT)-1)) ? ((desc_A->m)-(m2*(desc_A->mb))) : (desc_A->mb);
  int tempkn = ((k)==((NT)-1)) ? ((desc_A->n)-(k*(desc_A->nb))) : (desc_A->nb);
  int ib = DPLASMA_IB;
  int ldak = BLKLDDP( desc_A, k+1 );
  int ldam = BLKLDDP( desc_A, m2 );

  void *p_elem_A = dague_private_memory_pop( pool_0 );
  void *p_elem_B = dague_private_memory_pop( pool_1 );

  CORE_ztsqrt(tempmm, tempkn, ib, 
        S /* A(k+1,k) */, ldak, T /* A(m2,k) */, 
        ldam, U /* T(m2,k) */, desc_T->mb, 
        p_elem_A, p_elem_B );

  dague_private_memory_push( pool_0, p_elem_A );
  dague_private_memory_push( pool_1, p_elem_B );

  printlog("CORE_ztsqrt(%d, %d)\n\t(tempmm, tempkn, ib, A(%d,%d)[%p], ldak, A(%d,%d)[%p], ldam, T(%d,%d)[%p], desc_T->mb, p_elem_A, p_elem_B)\n",
  k, m2, k+1, k, S, m2, k, T, m2, k, U);

END

/*
 * Pseudo-task
 */
ztsqrt_out_desc_A0(k) [profile = off]
  k = 0..(MT-3)

  : A(k+1,k)

  RW S <- S ztsqrt(k,MT-1)
        -> A(k+1,k)
BODY
/* nothing */
END


/*
 * Pseudo-task
 */
ztsqrt_in_data_T1(k,m2) [profile = off]
  k = 0..(MT-3)
  m2 = (k+2)..(MT-1)

  : T(m2,k)

  RW U <- T(m2,k)
       -> U ztsqrt(k,m2)
BODY
/* nothing */
END


/*
 * Pseudo-task
 */
ztsqrt_out_data_T2(k,m2) [profile = off]
  k = 0..(MT-3)
  m2 = (k+2)..(MT-1)

  : T(m2,k)

  RW U <- U ztsqrt(k,m2)
        -> T(m2,k)
BODY
/* nothing */
END



ztsmqr(k,m2,n2)
  /* Execution space */
  k = 0.. minnt3mt2
  m2 = (k+2)..(MT-1)
  n2 = (k+1)..(NT-1)

  : A(m2,n2)

  /* A == A(k,k) */
  /* E == A(m,k) */
  /* G == A(k,n) */
  /* K == A(m1,n) */
  /* R == A(k+1,n1) */
  /* T == A(m2,k) */
  /* U == T(m2,k) */
  /* V == A(k+1,n2) */
  /* W == A(m2,n2) */
  /* X == A(m2,k) */
  /* Y == T(m2,k) */

  RW    V <- (m2>=(3+k)) ? V ztsmqr(k, m2-1, n2) 
          <- ((k+2)==m2) & (n2>=(k+1)) ? R zunmqr(m2-2, n2) 
          -> ((m2+1)==MT) & ((1+k)==n2) & (m2>=(k+2)) ? A zgelqt(n2) 
          -> (MT>=(m2+2)) ? V ztsmqr(k, m2+1, n2) 
          -> (MT==(1+m2)) & (n2>=(k+2)) ? G ztslqt(k+1, n2) 
  RW    W <- K ztsmlq(k, n2, m2) 
          -> (n2>=(k+2)) ? K ztsmlq(k+1, n2, m2) 
          -> ((k+1)==n2) & (m2>=(k+2)) & (MT>=(k+2)) ? E zunmlq(n2, m2) 
  READ  X <- T ztsqrt(k, m2) 
  READ  Y <- U ztsqrt(k, m2) 

  /*
  The following is a superset of the necessary anti-dependencies:

  */

BODY
  int tempnn = ((n2)==((NT)-1)) ? ((desc_A->n)-(n2*(desc_A->nb))) : (desc_A->nb);
  int tempmm = ((m2)==((MT)-1)) ? ((desc_A->m)-(m2*(desc_A->mb))) : (desc_A->mb);
  int ib = DPLASMA_IB;
  int ldak = BLKLDDP( desc_A, k+1 );
  int ldam = BLKLDDP( desc_A, m2 );
  int ldwork = ((PlasmaLeft)==(PlasmaLeft)) ? (ib) : (desc_T->nb);

  void *p_elem_A = dague_private_memory_pop( pool_1 );

  CORE_ztsmqr(PlasmaLeft, PlasmaConjTrans, desc_A->mb, 
        tempnn, tempmm, tempnn, 
        desc_A->nb, ib, V /* A(k+1,n2) */, 
        ldak, W /* A(m2,n2) */, ldam, 
        X /* A(m2,k) */, ldam, Y /* T(m2,k) */, 
        desc_T->mb, p_elem_A, ldwork );

  dague_private_memory_push( pool_1, p_elem_A );

  printlog("CORE_ztsmqr(%d, %d, %d)\n\t(PlasmaLeft, PlasmaConjTrans, desc_A->mb, tempnn, tempmm, tempnn, desc_A->nb, ib, A(%d,%d)[%p], ldak, A(%d,%d)[%p], ldam, A(%d,%d)[%p], ldam, T(%d,%d)[%p], desc_T->mb, p_elem_A, ldwork)\n",
  k, m2, n2, k+1, n2, V, m2, n2, W, m2, k, X, m2, k, Y);

END
