extern "C" %{
/*
 *  Copyright (c) 2010
 *
 *  The University of Tennessee and The University
 *  of Tennessee Research Foundation.  All rights
 *  reserved.
 *
 * @precisions normal z -> s d c
 *
 */
#define PRECISION_z

#include <plasma.h>
#include <core_blas.h>

#include "dague.h"
#include "data_dist/matrix/precision.h"
#include "data_dist/matrix/matrix.h"
#include "dplasma/lib/memory_pool.h"
#include "dplasma/lib/dplasmajdf.h"
#include "data_dist/matrix/two_dim_rectangle_cyclic.h"

#define max_thrdnbr_per_panel 48
#define nbthreads( __k ) (dague_imin( ((descA.mt - (__k)) + 3 )/  4, max_thrdnbr_per_panel) - 1)

PLASMA_desc plasma_desc_init(PLASMA_enum dtyp, int mb, int nb, int bsiz,
                             int lm, int ln, int i, int j, int m, int n);


%}

/** Globals */
descA     [type = "tiled_matrix_desc_t"]
A         [type = "dague_ddesc_t *"]
IPIV      [type = "dague_ddesc_t *"]
INFO      [type = "int*"]
minMNT    [type = "int" default="( (descA.mt < descA.nt) ? descA.mt-1 : descA.nt-1 )" hidden=on]

/************************************************************************************
 *                      Tiles 2 panel (Reduction version)
 *
 *  All Gemm from step k-1 on panel n have to be finished before
 *  to apply getrf or swptrsm on panel n
 ************************************************************************************/
/* tile2panel(k, n) [profile = off] */
/* k = 1..( (descA.mt < descA.nt) ? descA.mt-1 : descA.nt-1 ) */
/* n = k..descA.nt-1 */

/* :A(k, n) */

/* CTL  ctl <- ctlf gemm(k-1, k..descA.mt-1, n) */
/*          -> (n == k ) ? ctl getrf(k) : ctl swptrsm(k, n) */

/************************************************************************************
 *                      Tiles 2 panel (Forward)                                     *
 ************************************************************************************/
tile2panel(k, m, n) [profile = off]
  k = 0..minMNT
  m = k+1..descA.mt-1
  n = k+1..descA.nt-1
  ntrd = inline_c %{ return nbthreads( k+1 ); %}

  :A(k, n)

  CTL  ctl1 <- ctl gemm(k, m, n)
  CTL  ctl2 <- (m > k+1        ) ? ctl2 tile2panel(k, m-1, n)
            -> (m < descA.mt-1 )  ? ctl2 tile2panel(k, m+1, n)
            -> ((m == descA.mt-1 ) && (n == k+1)) ? ctl  getrf(k+1, 0..ntrd)
            -> ((m == descA.mt-1 ) && (n >  k+1)) ? ctl  swptrsm(k+1, n)
            -> (( m == descA.mt-1) && (k > 0 )) ? ctl1 subm2panel(k, n)

  ;descA.nt-n-1
BODY
    printlog("thread %d VP %d tile2panel( %d, %d, %d )\n",  context->th_id, context->virtual_process->vp_id, k, m, n);
END

/************************************************************************************
 *                    Submatrix 2 panel (backward)
 *
 * All the GEMM applied to the submatrix at step k-1 have to performed
 * before to do backward substitution from step k on previous panel
 *
 ************************************************************************************/
/* subm2panel(k, n) [profile = off] */
/* k = 1..( (descA.mt < descA.nt) ? descA.mt-1 : descA.nt-1 ) */

/* :A(k, k-1) */

/* CTL  ctl1 <- ctlb gemm(k-1, k..descA.mt-1, k+1..descA.nt-1) */
/*           -> ctl swpback(k, k-1) */
/* BODY */
/*      printlog("thread %d VP %d tile2panel( %d, %d, %d )\n",  context->th_id, context->virtual_process->vp_id, m, n, k); */
/* END */

/************************************************************************************
 *                    Submatrix 2 panel (backward)                                  *
 ************************************************************************************/
subm2panel(k, n) [profile = off]
  k = 1..minMNT
  n = k+1..descA.nt-1

  :A(k, n)

  CTL  ctl1 <- ctl2 tile2panel(k, descA.mt-1, n)
  CTL  ctl2 <- (n > k+1) ? ctl2 subm2panel(k, n-1)
            -> (n < descA.nt-1) ? ctl2 subm2panel(k, n+1) : ctl swpback(k, k-1)

  ;0
BODY
    printlog("thread %d VP %d subm2panel( %d, %d )\n", context->th_id, context->virtual_process->vp_id, k, n);
END

/************************************************************************************
 *                                    GETRF                                         *
 ************************************************************************************/
IPIV_in(k) [profile = off]
  k  = 0..minMNT
  nbtrd  = inline_c %{ return nbthreads( k ); %}

:IPIV(k, 0)

READ IP <- IPIV(k, 0)                [type = PIVOT]
        -> IPIV getrf(k, 0..nbtrd)   [type = PIVOT]

BODY
    /**/
END

IPIV_out(k) [profile = off]
  k  = 0..( (descA.mt < descA.nt) ? descA.mt-1 : descA.nt-1 )

:IPIV(k, 0)

READ IP <- IPIV getrf(k, 0)          [type = PIVOT]
        -> IPIV(k, 0)                [type = PIVOT]

BODY
    /**/
END

getrf(k, t) [high_priority = on]
  /* Execution space */
  k  = 0..minMNT
  t  = 0..inline_c %{ return nbthreads( k ); %}
  m1 = inline_c %{ return k + t * 4; %}
  m2 = inline_c %{ return dague_imin( k + (t+1) * 4 - 1, descA.mt-1); %}

  /* Locality */
  :A(k, k)

  RW    A    <- ( 0 == k ) ? A(k, k) : C gemm(k-1, k, k)
          /* <- A(m1..m2, k) : C gemm(k-1, m1..m2, k) */
             -> ((k < descA.nt-1) && (t == 0)) ? A swptrsm(k, k+1..descA.nt-1)
             -> (t == 0) ? A(k, k)
          /* -> A(m1..m2, k) */
  RW    IPIV <- IP IPIV_in(k)                                                    [type = PIVOT]
             -> ( t==0 ) ? IP IPIV_out(k)                                        [type = PIVOT]
             -> ((t==0) && (k < descA.nt-1)) ? IPIV swptrsm(k, k+1..descA.nt-1)  [type = PIVOT]
             -> ((t==0) && (k > 0)         ) ? IPIV swpback(k, 0..k-1)           [type = PIVOT]
  CTL   ctl  <- (k > 0) ? ctl2 tile2panel(k-1, descA.mt-1, k)
             -> (t == 0 ) ? ctl GEMM_A_in(k, k+1..descA.mt-1)
  /*  CTL   ctl  <- (k > 0) ? ctl2 tile2panel(k-1, m2,         k)*/

/* Priority */
;descA.nt-k-1

BODY

  int tempk  = k * descA.mb;
  int tempm  = descA.m - tempk;
  int tempkn = k == descA.nt-1 ? descA.n-k*descA.nb : descA.nb;
  int ldak = BLKLDD(descA, k);

  /* DRYRUN( */
      int tempkm = k == descA.mt-1 ? tempm : descA.mb;
      int nbthrd = nbthreads( k );
      int info[3];

      /* Set local IPIV to 0 before generation
       * Better here than a global initialization for locality
       * and it's also done in parallel */
      if ( t == 0 ) {
          memset(IPIV, 0, dague_imin(tempkn, tempkm) * sizeof(int) );
          /* fprintf(stderr, "There are %d threads woking on it\n", nbthrd); */
      }

      info[1] = t;
      info[2] = nbthrd+1;

      if ( descA.storage == matrix_Tile ) {
          PLASMA_desc pdescA = plasma_desc_init( PlasmaComplexDouble,
                                                 descA.mb, descA.nb, descA.mb * descA.nb,
                                                 (descA.mt-k)*descA.mb, descA.nb, 0, 0,
                                                 tempm, tempkn);
          pdescA.mat = A;
          CORE_zgetrf_rectil( pdescA, IPIV, info );

      } else {
          CORE_zgetrf_reclap(
              tempm, tempkn,
              A/*(k, k)*/, ldak, IPIV, info );
      }

      if ( (t == 0) && (info[0] != PLASMA_SUCCESS) ) {
          *INFO = tempk + info[0]; /* Should return if enter here */
          fprintf(stderr, "zgetrf(%d) failed => %d\n", k, *INFO );
      }
/*          ); */

   printlog("thread %d VP %d  CORE_zgetrf_rec(%d)\n"
            "\t(%d, %d, A(%d,%d)[%p], %d, IPIV(%d)[%p])\n",
             context->th_id, context->virtual_process->vp_id, k, tempm, tempkn, k, k, A, ldak, k, IPIV);

END


/************************************************************************************
 *                              SWAP + TRSM                                         *
 ************************************************************************************/

swptrsm(k, n)
  /* Execution space */
  k = 0..minMNT
  n = k+1..descA.nt-1

  /* Locality */
  :A(k, n)

  READ  A    <- A    getrf(k, 0)
  READ  IPIV <- IPIV getrf(k, 0)                                [type = PIVOT]
  RW    B    <- ( 0 == k ) ? A(k,n) : C gemm(k-1, k, n)
          /* <- A(k..descA.mt-1, n) : C gemm(k-1, k..descA.mt-1, n) */
             -> (k < descA.mt-1) ? B gemm(k, k+1..descA.mt-1, n)
             -> A(k, n)
  CTL   ctl  <- ( k > 0 ) ? ctl2 tile2panel(k-1, descA.mt-1, n)

/* Priority */
;descA.nt-n-1

BODY

/*   DRYRUN( */
         int tempkm = ((k)==(descA.mt-1)) ? (descA.m-(k*descA.mb)) : (descA.mb);
         int tempnn = ((n)==(descA.nt-1)) ? (descA.n-(n*descA.nb)) : (descA.nb);
         int ldak = BLKLDD(descA, k);

         if ( descA.storage == matrix_Tile ) {
             int tempk = k * descA.mb;
             int tempm = descA.m - tempk;
             PLASMA_desc pdescA = plasma_desc_init( PlasmaComplexDouble, 
                                                    descA.mb, descA.nb, descA.mb * descA.nb,
                                                    (descA.mt-k)*descA.mb, descA.nb, 0, 0,
                                                    tempm, tempnn);
             pdescA.mat = (void*)A;

             CORE_zlaswp_ontile(pdescA, 1, tempkm, IPIV, 1);
         } else {
             CORE_zlaswp( tempnn, B, descA.lm, 1, tempkm, IPIV, 1);
         }

         CORE_ztrsm(
             PlasmaLeft, PlasmaLower, PlasmaNoTrans, PlasmaUnit,
             tempkm, tempnn,
             1., A /*(k, k)*/, ldak,
                 B /*(k, n)*/, ldak);
/*          ); */

   printlog("thread %d VP %d CORE_zswptrsm(%d, %d)\n"
            "\t(%d, %d, A(%d,%d)[%p], B(%d,%d)[%p])\n",
            context->th_id, context->virtual_process->vp_id, k, n, tempkm, tempnn, k, k, A, k, n, B);

END

/************************************************************************************
 *                                    GEMM                                         *
 ************************************************************************************/
GEMM_A_in(k,m)
  /* Execution space */
  k = 0..minMNT
  m = k+1..descA.mt-1
    //myrank = inline_c %{ return A->rank_of(A, m, k); %}

  /* Locality */
:A(m, k)

  READ  A  <- ( k == 0 ) ? A(m, k) : C gemm(k-1, m, k)
           -> A gemm(k, m, k+1..descA.nt-1)
  CTL  ctl <- ctl getrf(k, 0)

BODY
  /* */
END


gemm(k,m,n)
  /* Execution space */
  k = 0..minMNT
  m = k+1..descA.mt-1
  n = k+1..descA.nt-1
  ntrd   = inline_c %{ return nbthreads( k+1 ); %}
  //  myrank = inline_c %{ return A->rank_of(A, m, n); %}

  /* Locality */
:A(m, n)

READ  A  <- A GEMM_A_in(k, m)
  READ  B  <- B swptrsm(k, n)
  RW    C  <- ( k   == 0 ) ? A(m, n) : C gemm(k-1, m, n)
           -> ( k+1 == n ) && ( k+1 == m ) ? A getrf(k+1, 0..ntrd)
           -> ( k+1 == n ) && ( k+1 <  m ) ? A GEMM_A_in(k+1, m)
           -> ( k+1 <  n ) && ( k+1 == m ) ? B swptrsm(k+1, n)
           -> ( k+1 <  n ) && ( k+1 <  m ) ? C gemm(k+1, m, n)
  CTL  ctl -> ctl1 tile2panel(k, m, n)

    /* Priority */
;descA.nt-n-1

BODY

  DRYRUN(
      int tempmm = ((m)==(descA.mt-1)) ? (descA.m-(m*descA.mb)) : (descA.mb);
      int tempnn = ((n)==(descA.nt-1)) ? (descA.n-(n*descA.nb)) : (descA.nb);
      int ldak = BLKLDD(descA, k);
      int ldam = BLKLDD(descA, m);

      CORE_zgemm(PlasmaNoTrans, PlasmaNoTrans,
                 tempmm, tempnn, descA.mb,
                 -1., A /*(m, k)*/, ldam,
                      B /*(k, n)*/, ldak,
                 1.,  C /*(m, n)*/, ldam );
         );
   printlog("thread %d VP %d CORE_zgemm(%d, %d, %d)\n"
            "\t(%d, %d, %d, A(%d,%d)[%p], %d, B(%d,%d)[%p], %d, C(%d,%d)[%p], %d)\n",
            context->th_id, context->virtual_process->vp_id, k, m, n, tempmm, tempnn, descA.mb, k, k, A, ldam, k, k, B, ldak, k, n, C, ldam);


END

/************************************************************************************
 *                              SWAP Backward                                       *
 ************************************************************************************/

swpback(k, n)
  /* Execution space */
  k = 1..minMNT
  n = 0..k-1

  /* Locality */
  :A(k, n)

  READ  IPIV <- IPIV getrf(k, 0)                                [type = PIVOT]
  RW    A    <- A(k, n)
             -> A(k, n)
  CTL   ctl  <- ((k < descA.nt-1) && (n == k-1)) ? ctl2 subm2panel(k, descA.nt-1)
             <- (n <  k-1)                                ? ctl swpback(k-1, n)
             -> (( k < descA.nt-1 ) && (k < descA.mt-1 )) ? ctl swpback(k+1, n)

/* Priority */
;0

BODY

/*   DRYRUN( */
      int tempkm = k == descA.mt-1 ? descA.m-k*descA.mb : descA.mb;
      int tempkn = k == descA.nt-1 ? descA.n-k*descA.nb : descA.nb;
      int tempmin = dague_imin(tempkn, tempkm);
      int ldak = BLKLDD(descA, k);

      if ( descA.storage == matrix_Tile ) {
          int tempk  = k * descA.mb;
          int tempm  = descA.m - tempk;
          PLASMA_desc pdescA = plasma_desc_init( PlasmaComplexDouble, 
                                                 descA.mb, descA.nb, descA.mb * descA.nb,
                                                 (descA.mt-k)*descA.mb, descA.nb, 0, 0,
                                                 tempm, descA.nb);
          pdescA.mat = (void*)A;
          CORE_zlaswp_ontile(pdescA, 1, tempmin, IPIV, 1);
      } else {
          CORE_zlaswp( descA.nb, A/*(k, n)*/, ldak, 1, tempmin, IPIV, 1 );
      }
/*          ); */


  printlog("thread %d VP %d CORE_zswpback(%d, %d)\n"
           "\t(%d, A(%d,%d)[%p], %d, IPIV(%d)[%p])\n",
           context->th_id, context->virtual_process->vp_id, k, n, descA.nb, k, n, A, ldak, k, IPIV);
END
